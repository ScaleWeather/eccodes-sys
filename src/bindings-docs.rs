/* automatically generated by rust-bindgen 0.58.1 */
// this file is only for documentation building

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const ECCODES_VERSION_STR: &'static [u8; 7usize] = b"2.22.1\0";
pub const ECCODES_MAJOR_VERSION: u32 = 2;
pub const ECCODES_MINOR_VERSION: u32 = 22;
pub const ECCODES_REVISION_VERSION: u32 = 1;
pub const ECCODES_VERSION: u32 = 22201;
pub const GRIB_SECTION_PRODUCT: u32 = 1;
pub const GRIB_SECTION_GRID: u32 = 2;
pub const GRIB_SECTION_LOCAL: u32 = 4;
pub const GRIB_SECTION_DATA: u32 = 8;
pub const GRIB_SECTION_BITMAP: u32 = 16;
pub const GRIB_LOG_INFO: u32 = 0;
pub const GRIB_LOG_WARNING: u32 = 1;
pub const GRIB_LOG_ERROR: u32 = 2;
pub const GRIB_LOG_FATAL: u32 = 3;
pub const GRIB_LOG_DEBUG: u32 = 4;
pub const GRIB_TYPE_UNDEFINED: u32 = 0;
pub const GRIB_TYPE_LONG: u32 = 1;
pub const GRIB_TYPE_DOUBLE: u32 = 2;
pub const GRIB_TYPE_STRING: u32 = 3;
pub const GRIB_TYPE_BYTES: u32 = 4;
pub const GRIB_TYPE_SECTION: u32 = 5;
pub const GRIB_TYPE_LABEL: u32 = 6;
pub const GRIB_TYPE_MISSING: u32 = 7;
pub const GRIB_MISSING_LONG: u32 = 2147483647;
pub const GRIB_MISSING_DOUBLE : f64 = - 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const GRIB_UTIL_SET_SPEC_FLAGS_ONLY_PACKING: u32 = 1;
pub const GRIB_DUMP_FLAG_READ_ONLY: u32 = 1;
pub const GRIB_DUMP_FLAG_DUMP_OK: u32 = 2;
pub const GRIB_DUMP_FLAG_VALUES: u32 = 4;
pub const GRIB_DUMP_FLAG_CODED: u32 = 8;
pub const GRIB_DUMP_FLAG_OCTET: u32 = 16;
pub const GRIB_DUMP_FLAG_ALIASES: u32 = 32;
pub const GRIB_DUMP_FLAG_TYPE: u32 = 64;
pub const GRIB_DUMP_FLAG_HEXADECIMAL: u32 = 128;
pub const GRIB_DUMP_FLAG_NO_DATA: u32 = 256;
pub const GRIB_DUMP_FLAG_ALL_DATA: u32 = 512;
pub const GRIB_DUMP_FLAG_ALL_ATTRIBUTES: u32 = 1024;
pub const GRIB_NEAREST_SAME_GRID: u32 = 1;
pub const GRIB_NEAREST_SAME_DATA: u32 = 2;
pub const GRIB_NEAREST_SAME_POINT: u32 = 4;
pub const GRIB_KEYS_ITERATOR_ALL_KEYS: u32 = 0;
pub const GRIB_KEYS_ITERATOR_SKIP_READ_ONLY: u32 = 1;
pub const GRIB_KEYS_ITERATOR_SKIP_OPTIONAL: u32 = 2;
pub const GRIB_KEYS_ITERATOR_SKIP_EDITION_SPECIFIC: u32 = 4;
pub const GRIB_KEYS_ITERATOR_SKIP_CODED: u32 = 8;
pub const GRIB_KEYS_ITERATOR_SKIP_COMPUTED: u32 = 16;
pub const GRIB_KEYS_ITERATOR_SKIP_DUPLICATES: u32 = 32;
pub const GRIB_KEYS_ITERATOR_SKIP_FUNCTION: u32 = 64;
pub const GRIB_KEYS_ITERATOR_DUMP_ONLY: u32 = 128;
pub const GRIB_UTIL_GRID_SPEC_REGULAR_LL: u32 = 1;
pub const GRIB_UTIL_GRID_SPEC_ROTATED_LL: u32 = 2;
pub const GRIB_UTIL_GRID_SPEC_REGULAR_GG: u32 = 3;
pub const GRIB_UTIL_GRID_SPEC_ROTATED_GG: u32 = 4;
pub const GRIB_UTIL_GRID_SPEC_REDUCED_GG: u32 = 5;
pub const GRIB_UTIL_GRID_SPEC_SH: u32 = 6;
pub const GRIB_UTIL_GRID_SPEC_REDUCED_LL: u32 = 7;
pub const GRIB_UTIL_GRID_SPEC_POLAR_STEREOGRAPHIC: u32 = 8;
pub const GRIB_UTIL_GRID_SPEC_REDUCED_ROTATED_GG: u32 = 9;
pub const GRIB_UTIL_GRID_SPEC_LAMBERT_AZIMUTHAL_EQUAL_AREA: u32 = 10;
pub const GRIB_UTIL_GRID_SPEC_LAMBERT_CONFORMAL: u32 = 11;
pub const GRIB_UTIL_GRID_SPEC_UNSTRUCTURED: u32 = 12;
pub const GRIB_UTIL_PACKING_TYPE_SAME_AS_INPUT: u32 = 0;
pub const GRIB_UTIL_PACKING_TYPE_SPECTRAL_COMPLEX: u32 = 1;
pub const GRIB_UTIL_PACKING_TYPE_SPECTRAL_SIMPLE: u32 = 2;
pub const GRIB_UTIL_PACKING_TYPE_JPEG: u32 = 3;
pub const GRIB_UTIL_PACKING_TYPE_GRID_COMPLEX: u32 = 4;
pub const GRIB_UTIL_PACKING_TYPE_GRID_SIMPLE: u32 = 5;
pub const GRIB_UTIL_PACKING_TYPE_GRID_SIMPLE_MATRIX: u32 = 6;
pub const GRIB_UTIL_PACKING_TYPE_GRID_SECOND_ORDER: u32 = 7;
pub const GRIB_UTIL_PACKING_TYPE_CCSDS: u32 = 8;
pub const GRIB_UTIL_PACKING_TYPE_IEEE: u32 = 9;
pub const GRIB_UTIL_PACKING_SAME_AS_INPUT: u32 = 0;
pub const GRIB_UTIL_PACKING_USE_PROVIDED: u32 = 1;
pub const GRIB_UTIL_ACCURACY_SAME_BITS_PER_VALUES_AS_INPUT: u32 = 0;
pub const GRIB_UTIL_ACCURACY_USE_PROVIDED_BITS_PER_VALUES: u32 = 1;
pub const GRIB_UTIL_ACCURACY_SAME_DECIMAL_SCALE_FACTOR_AS_INPUT: u32 = 2;
pub const GRIB_UTIL_ACCURACY_USE_PROVIDED_DECIMAL_SCALE_FACTOR: u32 = 3;
pub const GRIB_SUCCESS: u32 = 0;
pub const GRIB_END_OF_FILE: i32 = -1;
pub const GRIB_INTERNAL_ERROR: i32 = -2;
pub const GRIB_BUFFER_TOO_SMALL: i32 = -3;
pub const GRIB_NOT_IMPLEMENTED: i32 = -4;
pub const GRIB_7777_NOT_FOUND: i32 = -5;
pub const GRIB_ARRAY_TOO_SMALL: i32 = -6;
pub const GRIB_FILE_NOT_FOUND: i32 = -7;
pub const GRIB_CODE_NOT_FOUND_IN_TABLE: i32 = -8;
pub const GRIB_WRONG_ARRAY_SIZE: i32 = -9;
pub const GRIB_NOT_FOUND: i32 = -10;
pub const GRIB_IO_PROBLEM: i32 = -11;
pub const GRIB_INVALID_MESSAGE: i32 = -12;
pub const GRIB_DECODING_ERROR: i32 = -13;
pub const GRIB_ENCODING_ERROR: i32 = -14;
pub const GRIB_NO_MORE_IN_SET: i32 = -15;
pub const GRIB_GEOCALCULUS_PROBLEM: i32 = -16;
pub const GRIB_OUT_OF_MEMORY: i32 = -17;
pub const GRIB_READ_ONLY: i32 = -18;
pub const GRIB_INVALID_ARGUMENT: i32 = -19;
pub const GRIB_NULL_HANDLE: i32 = -20;
pub const GRIB_INVALID_SECTION_NUMBER: i32 = -21;
pub const GRIB_VALUE_CANNOT_BE_MISSING: i32 = -22;
pub const GRIB_WRONG_LENGTH: i32 = -23;
pub const GRIB_INVALID_TYPE: i32 = -24;
pub const GRIB_WRONG_STEP: i32 = -25;
pub const GRIB_WRONG_STEP_UNIT: i32 = -26;
pub const GRIB_INVALID_FILE: i32 = -27;
pub const GRIB_INVALID_GRIB: i32 = -28;
pub const GRIB_INVALID_INDEX: i32 = -29;
pub const GRIB_INVALID_ITERATOR: i32 = -30;
pub const GRIB_INVALID_KEYS_ITERATOR: i32 = -31;
pub const GRIB_INVALID_NEAREST: i32 = -32;
pub const GRIB_INVALID_ORDERBY: i32 = -33;
pub const GRIB_MISSING_KEY: i32 = -34;
pub const GRIB_OUT_OF_AREA: i32 = -35;
pub const GRIB_CONCEPT_NO_MATCH: i32 = -36;
pub const GRIB_HASH_ARRAY_NO_MATCH: i32 = -37;
pub const GRIB_NO_DEFINITIONS: i32 = -38;
pub const GRIB_WRONG_TYPE: i32 = -39;
pub const GRIB_END: i32 = -40;
pub const GRIB_NO_VALUES: i32 = -41;
pub const GRIB_WRONG_GRID: i32 = -42;
pub const GRIB_END_OF_INDEX: i32 = -43;
pub const GRIB_NULL_INDEX: i32 = -44;
pub const GRIB_PREMATURE_END_OF_FILE: i32 = -45;
pub const GRIB_INTERNAL_ARRAY_TOO_SMALL: i32 = -46;
pub const GRIB_MESSAGE_TOO_LARGE: i32 = -47;
pub const GRIB_CONSTANT_FIELD: i32 = -48;
pub const GRIB_SWITCH_NO_MATCH: i32 = -49;
pub const GRIB_UNDERFLOW: i32 = -50;
pub const GRIB_MESSAGE_MALFORMED: i32 = -51;
pub const GRIB_CORRUPTED_INDEX: i32 = -52;
pub const GRIB_INVALID_BPV: i32 = -53;
pub const GRIB_DIFFERENT_EDITION: i32 = -54;
pub const GRIB_VALUE_DIFFERENT: i32 = -55;
pub const GRIB_INVALID_KEY_VALUE: i32 = -56;
pub const GRIB_STRING_TOO_SMALL: i32 = -57;
pub const GRIB_WRONG_CONVERSION: i32 = -58;
pub const GRIB_MISSING_BUFR_ENTRY: i32 = -59;
pub const GRIB_NULL_POINTER: i32 = -60;
pub const GRIB_ATTRIBUTE_CLASH: i32 = -61;
pub const GRIB_TOO_MANY_ATTRIBUTES: i32 = -62;
pub const GRIB_ATTRIBUTE_NOT_FOUND: i32 = -63;
pub const GRIB_UNSUPPORTED_EDITION: i32 = -64;
pub const GRIB_OUT_OF_RANGE: i32 = -65;
pub const GRIB_WRONG_BITMAP_SIZE: i32 = -66;
pub const GRIB_FUNCTIONALITY_NOT_ENABLED: i32 = -67;
pub const CODES_VERSION: u32 = 22201;
pub const CODES_SECTION_PRODUCT: u32 = 1;
pub const CODES_SECTION_GRID: u32 = 2;
pub const CODES_SECTION_LOCAL: u32 = 4;
pub const CODES_SECTION_DATA: u32 = 8;
pub const CODES_SECTION_BITMAP: u32 = 16;
pub const CODES_LOG_INFO: u32 = 0;
pub const CODES_LOG_WARNING: u32 = 1;
pub const CODES_LOG_ERROR: u32 = 2;
pub const CODES_LOG_FATAL: u32 = 3;
pub const CODES_LOG_DEBUG: u32 = 4;
pub const CODES_TYPE_UNDEFINED: u32 = 0;
pub const CODES_TYPE_LONG: u32 = 1;
pub const CODES_TYPE_DOUBLE: u32 = 2;
pub const CODES_TYPE_STRING: u32 = 3;
pub const CODES_TYPE_BYTES: u32 = 4;
pub const CODES_TYPE_SECTION: u32 = 5;
pub const CODES_TYPE_LABEL: u32 = 6;
pub const CODES_TYPE_MISSING: u32 = 7;
pub const CODES_MISSING_LONG: u32 = 2147483647;
pub const CODES_MISSING_DOUBLE : f64 = - 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 ;
pub const CODES_UTIL_SET_SPEC_FLAGS_ONLY_PACKING: u32 = 1;
pub const CODES_DUMP_FLAG_READ_ONLY: u32 = 1;
pub const CODES_DUMP_FLAG_DUMP_OK: u32 = 2;
pub const CODES_DUMP_FLAG_VALUES: u32 = 4;
pub const CODES_DUMP_FLAG_CODED: u32 = 8;
pub const CODES_DUMP_FLAG_OCTET: u32 = 16;
pub const CODES_DUMP_FLAG_ALIASES: u32 = 32;
pub const CODES_DUMP_FLAG_TYPE: u32 = 64;
pub const CODES_DUMP_FLAG_HEXADECIMAL: u32 = 128;
pub const CODES_DUMP_FLAG_NO_DATA: u32 = 256;
pub const CODES_DUMP_FLAG_ALL_DATA: u32 = 512;
pub const CODES_DUMP_FLAG_ALL_ATTRIBUTES: u32 = 1024;
pub const CODES_NEAREST_SAME_GRID: u32 = 1;
pub const CODES_NEAREST_SAME_DATA: u32 = 2;
pub const CODES_NEAREST_SAME_POINT: u32 = 4;
pub const CODES_KEYS_ITERATOR_ALL_KEYS: u32 = 0;
pub const CODES_KEYS_ITERATOR_SKIP_READ_ONLY: u32 = 1;
pub const CODES_KEYS_ITERATOR_SKIP_OPTIONAL: u32 = 2;
pub const CODES_KEYS_ITERATOR_SKIP_EDITION_SPECIFIC: u32 = 4;
pub const CODES_KEYS_ITERATOR_SKIP_CODED: u32 = 8;
pub const CODES_KEYS_ITERATOR_SKIP_COMPUTED: u32 = 16;
pub const CODES_KEYS_ITERATOR_SKIP_DUPLICATES: u32 = 32;
pub const CODES_KEYS_ITERATOR_SKIP_FUNCTION: u32 = 64;
pub const CODES_KEYS_ITERATOR_DUMP_ONLY: u32 = 128;
pub const CODES_UTIL_GRID_SPEC_REGULAR_LL: u32 = 1;
pub const CODES_UTIL_GRID_SPEC_ROTATED_LL: u32 = 2;
pub const CODES_UTIL_GRID_SPEC_REGULAR_GG: u32 = 3;
pub const CODES_UTIL_GRID_SPEC_ROTATED_GG: u32 = 4;
pub const CODES_UTIL_GRID_SPEC_REDUCED_GG: u32 = 5;
pub const CODES_UTIL_GRID_SPEC_SH: u32 = 6;
pub const CODES_UTIL_GRID_SPEC_REDUCED_LL: u32 = 7;
pub const CODES_UTIL_GRID_SPEC_POLAR_STEREOGRAPHIC: u32 = 8;
pub const CODES_UTIL_GRID_SPEC_REDUCED_ROTATED_GG: u32 = 9;
pub const CODES_UTIL_GRID_SPEC_LAMBERT_AZIMUTHAL_EQUAL_AREA: u32 = 10;
pub const CODES_UTIL_GRID_SPEC_LAMBERT_CONFORMAL: u32 = 11;
pub const CODES_UTIL_GRID_SPEC_UNSTRUCTURED: u32 = 12;
pub const CODES_UTIL_PACKING_TYPE_SAME_AS_INPUT: u32 = 0;
pub const CODES_UTIL_PACKING_TYPE_SPECTRAL_COMPLEX: u32 = 1;
pub const CODES_UTIL_PACKING_TYPE_SPECTRAL_SIMPLE: u32 = 2;
pub const CODES_UTIL_PACKING_TYPE_JPEG: u32 = 3;
pub const CODES_UTIL_PACKING_TYPE_GRID_COMPLEX: u32 = 4;
pub const CODES_UTIL_PACKING_TYPE_GRID_SIMPLE: u32 = 5;
pub const CODES_UTIL_PACKING_TYPE_GRID_SIMPLE_MATRIX: u32 = 6;
pub const CODES_UTIL_PACKING_TYPE_GRID_SECOND_ORDER: u32 = 7;
pub const CODES_UTIL_PACKING_TYPE_CCSDS: u32 = 8;
pub const CODES_UTIL_PACKING_TYPE_IEEE: u32 = 9;
pub const CODES_UTIL_PACKING_SAME_AS_INPUT: u32 = 0;
pub const CODES_UTIL_PACKING_USE_PROVIDED: u32 = 1;
pub const CODES_UTIL_ACCURACY_SAME_BITS_PER_VALUES_AS_INPUT: u32 = 0;
pub const CODES_UTIL_ACCURACY_USE_PROVIDED_BITS_PER_VALUES: u32 = 1;
pub const CODES_UTIL_ACCURACY_SAME_DECIMAL_SCALE_FACTOR_AS_INPUT: u32 = 2;
pub const CODES_UTIL_ACCURACY_USE_PROVIDED_DECIMAL_SCALE_FACTOR: u32 = 3;
pub const CODES_SUCCESS: u32 = 0;
pub const CODES_END_OF_FILE: i32 = -1;
pub const CODES_INTERNAL_ERROR: i32 = -2;
pub const CODES_BUFFER_TOO_SMALL: i32 = -3;
pub const CODES_NOT_IMPLEMENTED: i32 = -4;
pub const CODES_7777_NOT_FOUND: i32 = -5;
pub const CODES_ARRAY_TOO_SMALL: i32 = -6;
pub const CODES_FILE_NOT_FOUND: i32 = -7;
pub const CODES_CODE_NOT_FOUND_IN_TABLE: i32 = -8;
pub const CODES_WRONG_ARRAY_SIZE: i32 = -9;
pub const CODES_NOT_FOUND: i32 = -10;
pub const CODES_IO_PROBLEM: i32 = -11;
pub const CODES_INVALID_MESSAGE: i32 = -12;
pub const CODES_DECODING_ERROR: i32 = -13;
pub const CODES_ENCODING_ERROR: i32 = -14;
pub const CODES_NO_MORE_IN_SET: i32 = -15;
pub const CODES_GEOCALCULUS_PROBLEM: i32 = -16;
pub const CODES_OUT_OF_MEMORY: i32 = -17;
pub const CODES_READ_ONLY: i32 = -18;
pub const CODES_INVALID_ARGUMENT: i32 = -19;
pub const CODES_NULL_HANDLE: i32 = -20;
pub const CODES_INVALID_SECTION_NUMBER: i32 = -21;
pub const CODES_VALUE_CANNOT_BE_MISSING: i32 = -22;
pub const CODES_WRONG_LENGTH: i32 = -23;
pub const CODES_INVALID_TYPE: i32 = -24;
pub const CODES_WRONG_STEP: i32 = -25;
pub const CODES_WRONG_STEP_UNIT: i32 = -26;
pub const CODES_INVALID_FILE: i32 = -27;
pub const CODES_INVALID_GRIB: i32 = -28;
pub const CODES_INVALID_INDEX: i32 = -29;
pub const CODES_INVALID_ITERATOR: i32 = -30;
pub const CODES_INVALID_KEYS_ITERATOR: i32 = -31;
pub const CODES_INVALID_NEAREST: i32 = -32;
pub const CODES_INVALID_ORDERBY: i32 = -33;
pub const CODES_MISSING_KEY: i32 = -34;
pub const CODES_OUT_OF_AREA: i32 = -35;
pub const CODES_CONCEPT_NO_MATCH: i32 = -36;
pub const CODES_HASH_ARRAY_NO_MATCH: i32 = -37;
pub const CODES_NO_DEFINITIONS: i32 = -38;
pub const CODES_WRONG_TYPE: i32 = -39;
pub const CODES_END: i32 = -40;
pub const CODES_NO_VALUES: i32 = -41;
pub const CODES_WRONG_GRID: i32 = -42;
pub const CODES_END_OF_INDEX: i32 = -43;
pub const CODES_NULL_INDEX: i32 = -44;
pub const CODES_PREMATURE_END_OF_FILE: i32 = -45;
pub const CODES_INTERNAL_ARRAY_TOO_SMALL: i32 = -46;
pub const CODES_MESSAGE_TOO_LARGE: i32 = -47;
pub const CODES_CONSTANT_FIELD: i32 = -48;
pub const CODES_SWITCH_NO_MATCH: i32 = -49;
pub const CODES_UNDERFLOW: i32 = -50;
pub const CODES_MESSAGE_MALFORMED: i32 = -51;
pub const CODES_CORRUPTED_INDEX: i32 = -52;
pub const CODES_INVALID_BPV: i32 = -53;
pub const CODES_DIFFERENT_EDITION: i32 = -54;
pub const CODES_VALUE_DIFFERENT: i32 = -55;
pub const CODES_INVALID_KEY_VALUE: i32 = -56;
pub const CODES_STRING_TOO_SMALL: i32 = -57;
pub const CODES_WRONG_CONVERSION: i32 = -58;
pub const CODES_MISSING_BUFR_ENTRY: i32 = -59;
pub const CODES_NULL_POINTER: i32 = -60;
pub const CODES_ATTRIBUTE_CLASH: i32 = -61;
pub const CODES_TOO_MANY_ATTRIBUTES: i32 = -62;
pub const CODES_ATTRIBUTE_NOT_FOUND: i32 = -63;
pub const CODES_UNSUPPORTED_EDITION: i32 = -64;
pub const CODES_OUT_OF_RANGE: i32 = -65;
pub const CODES_WRONG_BITMAP_SIZE: i32 = -66;
pub const CODES_FUNCTIONALITY_NOT_ENABLED: i32 = -67;
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: ::std::os::raw::c_uint = 0;
pub const FP_INFINITE: ::std::os::raw::c_uint = 1;
pub const FP_ZERO: ::std::os::raw::c_uint = 2;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const ProductKind_PRODUCT_ANY: ProductKind = 0;
pub const ProductKind_PRODUCT_GRIB: ProductKind = 1;
pub const ProductKind_PRODUCT_BUFR: ProductKind = 2;
pub const ProductKind_PRODUCT_METAR: ProductKind = 3;
pub const ProductKind_PRODUCT_GTS: ProductKind = 4;
pub const ProductKind_PRODUCT_TAF: ProductKind = 5;
pub type ProductKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_key_value_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_values {
    pub name: *const ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_int,
    pub long_value: ::std::os::raw::c_long,
    pub double_value: f64,
    pub string_value: *const ::std::os::raw::c_char,
    pub error: ::std::os::raw::c_int,
    pub has_value: ::std::os::raw::c_int,
    pub equal: ::std::os::raw::c_int,
    pub next: *mut grib_values,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_multi_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_nearest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_box {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_keys_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufr_keys_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_fieldset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_order_by {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_where {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_sarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_oarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_darray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_iarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_vdarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_vsarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_viarray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufr_descriptor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufr_descriptors_array {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufr_descriptors_map_list {
    _unused: [u8; 0],
}
extern "C" {
    pub fn grib_fieldset_new_from_files(
        c: *mut grib_context,
        filenames: *mut *mut ::std::os::raw::c_char,
        nfiles: ::std::os::raw::c_int,
        keys: *mut *mut ::std::os::raw::c_char,
        nkeys: ::std::os::raw::c_int,
        where_string: *const ::std::os::raw::c_char,
        order_by_string: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_fieldset;
}
extern "C" {
    pub fn grib_fieldset_delete(set: *mut grib_fieldset);
}
extern "C" {
    pub fn grib_fieldset_rewind(set: *mut grib_fieldset);
}
extern "C" {
    pub fn grib_fieldset_apply_order_by(
        set: *mut grib_fieldset,
        order_by_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_fieldset_next_handle(
        set: *mut grib_fieldset,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn grib_fieldset_count(set: *mut grib_fieldset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_values_check(
        h: *mut grib_handle,
        values: *mut grib_values,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_index {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  Create a new index form a file. The file is indexed with the keys in argument."]
    #[doc = ""]
    #[doc = " @param c           : context  (NULL for default context)"]
    #[doc = " @param filename    : name of the file of messages to be indexed"]
    #[doc = " @param keys        : comma separated list of keys for the index."]
    #[doc = "    The type of the key can be explicitly declared appending :l for long,"]
    #[doc = "    (or alternatively :i)"]
    #[doc = "    :d for double, :s for string to the key name. If the type is not"]
    #[doc = "    declared explicitly, the native type is assumed."]
    #[doc = " @param err         :  0 if OK, integer value on error"]
    #[doc = " @return            the newly created index"]
    pub fn grib_index_new_from_file(
        c: *mut grib_context,
        filename: *const ::std::os::raw::c_char,
        keys: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_index;
}
extern "C" {
    #[doc = "  Create a new index based on a set of keys."]
    #[doc = ""]
    #[doc = " @param c           : context  (NULL for default context)"]
    #[doc = " @param keys        : comma separated list of keys for the index."]
    #[doc = "    The type of the key can be explicitly declared appending \":l\" for long,"]
    #[doc = "    (or alternatively \":i\"), \":d\" for double, \":s\" for string to the key name. If the type is not"]
    #[doc = "    declared explicitly, the native type is assumed."]
    #[doc = " @param err         :  0 if OK, integer value on error"]
    #[doc = " @return            the newly created index"]
    pub fn grib_index_new(
        c: *mut grib_context,
        keys: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_index;
}
extern "C" {
    pub fn codes_index_set_product_kind(
        index: *mut grib_index,
        product_kind: ProductKind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_index_set_unpack_bufr(
        index: *mut grib_index,
        unpack: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Indexes the file given in argument in the index given in argument."]
    #[doc = ""]
    #[doc = " @param index       : index"]
    #[doc = " @param filename    : name of the file of messages to be indexed"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_add_file(
        index: *mut grib_index,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_index_write(
        index: *mut grib_index,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_index_read(
        c: *mut grib_context,
        filename: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_index;
}
extern "C" {
    #[doc = "  Get the number of distinct values of the key in argument contained in the index. The key must belong to the index."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the number of values is computed"]
    #[doc = " @param size        : number of distinct values of the key in the index"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_get_size(
        index: *const grib_index,
        key: *const ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as long or when the native type of the key is long."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_get_long(
        index: *const grib_index,
        key: *const ::std::os::raw::c_char,
        values: *mut ::std::os::raw::c_long,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as double or when the native type of the key is double."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_get_double(
        index: *const grib_index,
        key: *const ::std::os::raw::c_char,
        values: *mut f64,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as string or when the native type of the key is string."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_get_string(
        index: *const grib_index,
        key: *const ::std::os::raw::c_char,
        values: *mut *mut ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Select the message subset with key==value. The value is a long. The key must have been created with long type or have long as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_select_long(
        index: *mut grib_index,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Select the message subset with key==value. The value is a double. The key must have been created with double type or have double as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_select_double(
        index: *mut grib_index,
        key: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Select the message subset with key==value. The value is a string. The key must have been created with string type or have string as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_index_select_string(
        index: *mut grib_index,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Create a new handle from an index after having selected the key values."]
    #[doc = "  All the keys belonging to the index must be selected before calling this function. Successive calls to this function will return all the handles compatible with the constraints defined selecting the values of the index keys."]
    #[doc = " When no more handles are available from the index a NULL pointer is returned and the err variable is set to GRIB_END_OF_INDEX."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = " @param err         : 0 if OK, integer value on error. GRIB_END_OF_INDEX when no more handles are contained in the index."]
    #[doc = " @return            GRIB handle."]
    pub fn grib_handle_new_from_index(
        index: *mut grib_index,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Delete the index."]
    #[doc = ""]
    #[doc = " @param index       : index to be deleted."]
    pub fn grib_index_delete(index: *mut grib_index);
}
extern "C" {
    #[doc = " \\defgroup grib_handle The grib_handle"]
    #[doc = "The grib_handle is the structure giving access to parsed grib values by keys."]
    #[doc = "  Counts the messages contained in a file resource."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param n           : the number of messages in the file"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_count_in_file(
        c: *mut grib_context,
        f: *mut FILE,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Counts the messages contained in a file."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param filename    : the path to the file"]
    #[doc = " @param n           : the number of messages in the file"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_count_in_filename(
        c: *mut grib_context,
        filename: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Create a handle from a file resource."]
    #[doc = "  The file is read until a message is found. The message is then copied."]
    #[doc = "  Remember always to delete the handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param error       : error code set if the returned handle is NULL and the end of file is not reached"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn grib_handle_new_from_file(
        c: *mut grib_context,
        f: *mut FILE,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Write a coded message in a file."]
    #[doc = ""]
    #[doc = " @param h           : grib_handle to be written"]
    #[doc = " @param file        : name of the file"]
    #[doc = " @param mode        : mode"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_write_message(
        h: *const grib_handle,
        file: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_string_list {
    pub value: *mut ::std::os::raw::c_char,
    pub count: ::std::os::raw::c_int,
    pub next: *mut grib_string_list,
}
extern "C" {
    pub fn grib_util_sections_copy(
        hfrom: *mut grib_handle,
        hto: *mut grib_handle,
        what: ::std::os::raw::c_int,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn grib_util_get_param_id(
        mars_param: *const ::std::os::raw::c_char,
    ) -> *mut grib_string_list;
}
extern "C" {
    pub fn grib_util_get_mars_param(
        param_id: *const ::std::os::raw::c_char,
    ) -> *mut grib_string_list;
}
extern "C" {
    #[doc = "  Create a handle from a user message in memory. The message will not be freed at the end."]
    #[doc = "  The message will be copied as soon as a modification is needed."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn grib_handle_new_from_message(
        c: *mut grib_context,
        data: *const ::std::os::raw::c_void,
        data_len: size_t,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Create a handle from a user message in memory. The message will not be freed at the end."]
    #[doc = "  The message will be copied as soon as a modification is needed."]
    #[doc = "  This function works also with multi-field messages."]
    #[doc = "  Note: The data pointer argument may be modified"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @param error       : error code"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn grib_handle_new_from_multi_message(
        c: *mut grib_context,
        data: *mut *mut ::std::os::raw::c_void,
        data_len: *mut size_t,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Create a handle from a user message. The message is copied and will be freed with the handle"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn grib_handle_new_from_message_copy(
        c: *mut grib_context,
        data: *const ::std::os::raw::c_void,
        data_len: size_t,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Create a handle from a GRIB message contained in the samples directory."]
    #[doc = "  The message is copied at the creation of the handle"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param sample_name : the name of the sample file (without the .tmpl extension)"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn grib_handle_new_from_samples(
        c: *mut grib_context,
        sample_name: *const ::std::os::raw::c_char,
    ) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Clone an existing handle using the context of the original handle,"]
    #[doc = "  The message is copied and reparsed"]
    #[doc = ""]
    #[doc = " @param h           : The handle to be cloned"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn grib_handle_clone(h: *const grib_handle) -> *mut grib_handle;
}
extern "C" {
    #[doc = "  Frees a handle, also frees the message if it is not a user message"]
    #[doc = "  @see  grib_handle_new_from_message"]
    #[doc = " @param h           : The handle to be deleted"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_handle_delete(h: *mut grib_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Create an empty multi-field handle."]
    #[doc = "  Remember always to delete the multi handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    pub fn grib_multi_handle_new(c: *mut grib_context) -> *mut grib_multi_handle;
}
extern "C" {
    #[doc = "  Append the sections starting with start_section of the message pointed by h at"]
    #[doc = "  the end of the multi-field handle mh."]
    #[doc = "  Remember always to delete the multi handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param h           : The handle from which the sections are copied."]
    #[doc = " @param start_section : section number. Starting from this section all the sections to the end of the message will be copied."]
    #[doc = " @param mh           : The multi field handle on which the sections are appended."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_multi_handle_append(
        h: *mut grib_handle,
        start_section: ::std::os::raw::c_int,
        mh: *mut grib_multi_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete multi-field handle."]
    #[doc = ""]
    #[doc = " @param mh          : The multi-field handle to be deleted."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_multi_handle_delete(mh: *mut grib_multi_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Write a multi-field handle in a file."]
    #[doc = "  Remember to delete the multi handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param mh          : The multi field handle to be written."]
    #[doc = " @param f           : File on which the file handle is written."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_multi_handle_write(
        mh: *mut grib_multi_handle,
        f: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup handling_coded_messages Handling coded messages */"]
    #[doc = " getting the message attached to a handle"]
    #[doc = ""]
    #[doc = " @param h              : the handle to which the buffer should be gathered"]
    #[doc = " @param message        : the pointer to be set to the handle's data"]
    #[doc = " @param message_length : On exit, the message size in number of bytes"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_message(
        h: *const grib_handle,
        message: *mut *const ::std::os::raw::c_void,
        message_length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getting a copy of the message attached to a handle"]
    #[doc = ""]
    #[doc = " @param h              : the handle to which the buffer should be returned"]
    #[doc = " @param message        : the pointer to the data buffer to be filled"]
    #[doc = " @param message_length : On entry, the size in number of bytes of the allocated empty message."]
    #[doc = "                         On exit, the actual message length in number of bytes"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_message_copy(
        h: *const grib_handle,
        message: *mut ::std::os::raw::c_void,
        message_length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new geoiterator from a handle, using current geometry and values."]
    #[doc = ""]
    #[doc = " \\param h           : the handle from which the geoiterator will be created"]
    #[doc = " \\param flags       : flags for future use."]
    #[doc = " \\param error       : error code"]
    #[doc = " \\return            the new geoiterator, NULL if no geoiterator can be created"]
    pub fn grib_iterator_new(
        h: *const grib_handle,
        flags: ::std::os::raw::c_ulong,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut grib_iterator;
}
extern "C" {
    #[doc = " Get latitude/longitude and data values."]
    #[doc = " The Latitudes, longitudes and values arrays must be properly allocated by the caller."]
    #[doc = " Their required dimension can be obtained by getting the value of the integer key \"numberOfPoints\"."]
    #[doc = ""]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param lats        : returned array of latitudes"]
    #[doc = " @param lons        : returned array of longitudes"]
    #[doc = " @param values      : returned array of data values"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_data(
        h: *const grib_handle,
        lats: *mut f64,
        lons: *mut f64,
        values: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next value from a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @param lat         : on output latitude in degree"]
    #[doc = " @param lon         : on output longitude in degree"]
    #[doc = " @param value       : on output value of the point"]
    #[doc = " @return            positive value if successful, 0 if no more data are available"]
    pub fn grib_iterator_next(
        i: *mut grib_iterator,
        lat: *mut f64,
        lon: *mut f64,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the previous value from a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @param lat         : on output latitude in degree"]
    #[doc = " @param lon         : on output longitude in degree"]
    #[doc = " @param value       : on output value of the point*"]
    #[doc = " @return            positive value if successful, 0 if no more data are available"]
    pub fn grib_iterator_previous(
        i: *mut grib_iterator,
        lat: *mut f64,
        lon: *mut f64,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test procedure for values in a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            boolean, 1 if the geoiterator still nave next values, 0 otherwise"]
    pub fn grib_iterator_has_next(i: *mut grib_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test procedure for values in a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_iterator_reset(i: *mut grib_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Frees a geoiterator from memory"]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_iterator_delete(i: *mut grib_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new nearest neighbour object from a handle, using current geometry."]
    #[doc = ""]
    #[doc = " \\param h           : the handle from which the nearest object will be created"]
    #[doc = " \\param error       : error code"]
    #[doc = " \\return            the new nearest, NULL if no nearest can be created"]
    pub fn grib_nearest_new(
        h: *const grib_handle,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut grib_nearest;
}
extern "C" {
    #[doc = " Find the 4 nearest points of a latitude longitude point."]
    #[doc = " The flags are provided to speed up the process of searching. If you are"]
    #[doc = " sure that the point you are asking for is not changing from a call"]
    #[doc = " to another you can use GRIB_NEAREST_SAME_POINT. The same is valid for"]
    #[doc = " the grid. Flags can be used together doing a bitwise OR."]
    #[doc = " The distances are given in kilometres."]
    #[doc = ""]
    #[doc = " @param nearest     : nearest structure"]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param inlat       : latitude of the point to search for"]
    #[doc = " @param inlon       : longitude of the point to search for"]
    #[doc = " @param flags       : GRIB_NEAREST_SAME_POINT, GRIB_NEAREST_SAME_GRID"]
    #[doc = " @param outlats     : returned array of latitudes of the nearest points"]
    #[doc = " @param outlons     : returned array of longitudes of the nearest points"]
    #[doc = " @param values      : returned array of data values of the nearest points"]
    #[doc = " @param distances   : returned array of distances from the nearest points"]
    #[doc = " @param indexes     : returned array of indexes of the nearest points"]
    #[doc = " @param len         : size of the arrays"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_nearest_find(
        nearest: *mut grib_nearest,
        h: *const grib_handle,
        inlat: f64,
        inlon: f64,
        flags: ::std::os::raw::c_ulong,
        outlats: *mut f64,
        outlons: *mut f64,
        values: *mut f64,
        distances: *mut f64,
        indexes: *mut ::std::os::raw::c_int,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Frees a nearest neighbour object from memory"]
    #[doc = ""]
    #[doc = " @param nearest     : the nearest"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_nearest_delete(nearest: *mut grib_nearest) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the nearest point of a set of points whose latitudes and longitudes"]
    #[doc = " are given in the inlats, inlons arrays respectively."]
    #[doc = " If the flag is_lsm is 1 the nearest land point is returned and the"]
    #[doc = " GRIB passed as handle (h) is considered a land sea mask."]
    #[doc = " The land nearest point is the nearest point with land sea mask value>=0.5."]
    #[doc = " If no nearest land points are found the nearest value is returned."]
    #[doc = " If the flag is_lsm is 0 the nearest point is returned."]
    #[doc = " values, distances, indexes (in the \"values\" array) for the nearest points (ilons,ilats)"]
    #[doc = " are returned."]
    #[doc = " The distances are given in kilometres."]
    #[doc = ""]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param is_lsm      : lsm flag (1-> nearest land, 0-> nearest)"]
    #[doc = " @param inlats      : latitudes of the points to search for"]
    #[doc = " @param inlons      : longitudes of the points to search for"]
    #[doc = " @param npoints     : number of points (size of the inlats,inlons,outlats,outlons,values,distances,indexes arrays)"]
    #[doc = " @param outlats     : returned array of latitudes of the nearest points"]
    #[doc = " @param outlons     : returned array of longitudes of the nearest points"]
    #[doc = " @param values      : returned array of data values of the nearest points"]
    #[doc = " @param distances   : returned array of distances from the nearest points"]
    #[doc = " @param indexes     : returned array of indexes of the nearest points"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_nearest_find_multiple(
        h: *const grib_handle,
        is_lsm: ::std::os::raw::c_int,
        inlats: *const f64,
        inlons: *const f64,
        npoints: ::std::os::raw::c_long,
        outlats: *mut f64,
        outlons: *mut f64,
        values: *mut f64,
        distances: *mut f64,
        indexes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup get_set Accessing header and data values   */"]
    #[doc = "  Get the number offset of a key, in a message if several keys of the same name"]
    #[doc = "  are present, the offset of the last one is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param offset      : the address of a size_t where the offset will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_offset(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of coded value from a key, if several keys of the same name are present, the total sum is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param size        : the address of a size_t where the size will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_size(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the length of the string representation of the key, if several keys of the same name are present, the maximum length is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param length      : the address of a size_t where the length will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_length(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a long value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = "  @see  grib_set_long"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param value       : the address of a long where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_long(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a double value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = "  @see  grib_set_double"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param value       : the address of a double where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_double(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get as double the i-th element of the \"key\" array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param i           : zero-based index"]
    #[doc = " @param value       : the address of a double where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_double_element(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get as double array the elements of the \"key\" array whose indexes are listed in the input array i"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param i           : zero-based array of indexes"]
    #[doc = " @param size        : size of the i and value arrays"]
    #[doc = " @param value       : the double array for the data values"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_double_elements(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        i: *mut ::std::os::raw::c_int,
        size: ::std::os::raw::c_long,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a string value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = " @see  grib_set_string"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param mesg       : the address of a string where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the string on input, and that contains the actual length of the string on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_string(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        mesg: *mut ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get string array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  grib_set_string_array"]
    #[doc = ""]
    #[doc = " @param h       : the handle to get the data from"]
    #[doc = " @param key     : the key to be searched"]
    #[doc = " @param vals    : the address of a string array where the data will be retrieved"]
    #[doc = " @param length  : the address of a size_t that contains allocated length of the array on input, and that contains the actual length of the array on output"]
    #[doc = " @return        0 if OK, integer value on error"]
    pub fn grib_get_string_array(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut *mut ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get raw bytes values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  grib_set_bytes"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param bytes       : the address of a byte array where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the byte array on input, and that contains the actual length of the byte array on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_bytes(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        bytes: *mut ::std::os::raw::c_uchar,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get double array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  grib_set_double_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals       : the address of a double array where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the double array on input, and that contains the actual length of the double array on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_double_array(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut f64,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get long array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  grib_set_long_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals       : the address of a long array where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the long array on input, and that contains the actual length of the long array on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_get_long_array(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut ::std::os::raw::c_long,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Copy the keys belonging to a given namespace from a source handle to a destination handle"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param dest      : destination handle"]
    #[doc = " @param name      : namespace"]
    #[doc = " @param src       : source handle"]
    #[doc = " @return          0 if OK, integer value on error"]
    pub fn grib_copy_namespace(
        dest: *mut grib_handle,
        name: *const ::std::os::raw::c_char,
        src: *mut grib_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a long value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_long"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param val         : a long where the data will be read"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_long(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a double value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_double"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param val       : a double where the data will be read"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_double(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a string value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_string"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param mesg       : the address of a string where the data will be read"]
    #[doc = " @param length      : the address of a size_t that contains the length of the string on input, and that contains the actual packed length of the string on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_string(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        mesg: *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a bytes array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_bytes"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param bytes       : the address of a byte array where the data will be read"]
    #[doc = " @param length      : the address of a size_t that contains the length of the byte array on input, and that contains the actual packed length of the byte array  on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_bytes(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        bytes: *const ::std::os::raw::c_uchar,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a double array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "   @see  grib_get_double_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a double array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the byte array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_double_array(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const f64,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as grib_set_double_array but allows setting of READ-ONLY keys like codedValues."]
    #[doc = " Use with great caution!!"]
    pub fn grib_set_force_double_array(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const f64,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a long array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_long_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a long array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the long array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_long_array(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const ::std::os::raw::c_long,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a string array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  grib_get_string_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a string array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn grib_set_string_array(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut *const ::std::os::raw::c_char,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Print all keys, with the context print procedure and dump mode to a resource"]
    #[doc = ""]
    #[doc = " @param h            : the handle to be printed"]
    #[doc = " @param out          : output file handle"]
    #[doc = " @param mode         : Examples of available dump modes: debug wmo"]
    #[doc = " @param option_flags : all the GRIB_DUMP_FLAG_x flags can be used"]
    #[doc = " @param arg          : used to provide a format to output data (experimental)"]
    pub fn grib_dump_content(
        h: *const grib_handle,
        out: *mut FILE,
        mode: *const ::std::os::raw::c_char,
        option_flags: ::std::os::raw::c_ulong,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  Print all keys from the parsed definition files available in a context"]
    #[doc = ""]
    #[doc = " @param f           : the File used to print the keys on"]
    #[doc = " @param c           : the context that contains the cached definition files to be printed"]
    pub fn grib_dump_action_tree(c: *mut grib_context, f: *mut FILE);
}
#[doc = " \\defgroup context The context object"]
#[doc = "The context is a long life configuration object of the grib_api."]
#[doc = "It is used to define special allocation and free routines or"]
#[doc = "to set special grib_api behaviours and variables."]
#[doc = " Grib free procedure, format of a procedure referenced in the context that is used to free memory"]
#[doc = ""]
#[doc = " @param c           : the context where the memory freeing will apply"]
#[doc = " @param data        : pointer to the data to be freed"]
#[doc = " must match @see grib_malloc_proc"]
pub type grib_free_proc = ::std::option::Option<
    unsafe extern "C" fn(c: *const grib_context, data: *mut ::std::os::raw::c_void),
>;
#[doc = " Grib malloc procedure, format of a procedure referenced in the context that is used to allocate memory"]
#[doc = " @param c             : the context where the memory allocation will apply"]
#[doc = " @param length        : length to be allocated in number of bytes"]
#[doc = " @return              a pointer to the allocated memory, NULL if no memory can be allocated"]
#[doc = " must match @see grib_free_proc"]
pub type grib_malloc_proc = ::std::option::Option<
    unsafe extern "C" fn(c: *const grib_context, length: size_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Grib realloc procedure, format of a procedure referenced in the context that is used to reallocate memory"]
#[doc = " @param c             : the context where the memory allocation will apply"]
#[doc = " @param data          : pointer to the data to be reallocated"]
#[doc = " @param length        : length to be allocated in number of bytes"]
#[doc = " @return              a pointer to the allocated memory"]
pub type grib_realloc_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        data: *mut ::std::os::raw::c_void,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Grib loc proc, format of a procedure referenced in the context that is used to log internal messages"]
#[doc = ""]
#[doc = " @param c             : the context where the logging will apply"]
#[doc = " @param level         : the log level, as defined in log modes"]
#[doc = " @param mesg          : the message to be logged"]
pub type grib_log_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        level: ::std::os::raw::c_int,
        mesg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Grib print proc, format of a procedure referenced in the context that is used to print external messages"]
#[doc = ""]
#[doc = " @param c             : the context where the logging will apply"]
#[doc = " @param descriptor    : the structure to be printed on, must match the implementation"]
#[doc = " @param mesg          : the message to be printed"]
pub type grib_print_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        descriptor: *mut ::std::os::raw::c_void,
        mesg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Grib data read proc, format of a procedure referenced in the context that is used to read from a stream in a resource"]
#[doc = ""]
#[doc = " @param c             : the context where the read will apply"]
#[doc = " @param ptr          : the resource"]
#[doc = " @param size          : size to read"]
#[doc = " @param stream       : the stream"]
#[doc = " @return              size read"]
pub type grib_data_read_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        stream: *mut ::std::os::raw::c_void,
    ) -> size_t,
>;
#[doc = " Grib data read write, format of a procedure referenced in the context that is used to write to a stream from a resource"]
#[doc = ""]
#[doc = " @param c             : the context where the write will apply"]
#[doc = " @param ptr          : the resource"]
#[doc = " @param size          : size to read"]
#[doc = " @param stream       : the stream"]
#[doc = " @return              size written"]
pub type grib_data_write_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        stream: *mut ::std::os::raw::c_void,
    ) -> size_t,
>;
#[doc = " Grib data tell, format of a procedure referenced in the context that is used to tell the current position in a stream"]
#[doc = ""]
#[doc = " @param c             : the context where the tell will apply"]
#[doc = " @param stream       : the stream"]
#[doc = " @return              the position in the stream"]
pub type grib_data_tell_proc = ::std::option::Option<
    unsafe extern "C" fn(c: *const grib_context, stream: *mut ::std::os::raw::c_void) -> off_t,
>;
#[doc = " Grib data seek, format of a procedure referenced in the context that is used to seek the current position in a stream"]
#[doc = ""]
#[doc = " @param c             : the context where the tell will apply"]
#[doc = " @param offset        : the offset to seek to"]
#[doc = " @param whence        : If whence is set to SEEK_SET, SEEK_CUR, or SEEK_END,"]
#[doc = "the offset  is  relative  to  the start of the file,"]
#[doc = "the current position indicator, or end-of-file, respectively."]
#[doc = " @param stream       : the stream"]
#[doc = " @return            0 if OK, integer value on error"]
pub type grib_data_seek_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        offset: off_t,
        whence: ::std::os::raw::c_int,
        stream: *mut ::std::os::raw::c_void,
    ) -> off_t,
>;
#[doc = " Grib data eof, format of a procedure referenced in the context that is used to test end of file"]
#[doc = ""]
#[doc = " @param c             : the context where the tell will apply"]
#[doc = " @param stream       : the stream"]
#[doc = " @return              the position in the stream"]
pub type grib_data_eof_proc = ::std::option::Option<
    unsafe extern "C" fn(
        c: *const grib_context,
        stream: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "  Get the static default context"]
    #[doc = ""]
    #[doc = " @return            the default context, NULL it the context is not available"]
    pub fn grib_context_get_default() -> *mut grib_context;
}
extern "C" {
    #[doc = "  Frees the cached definition files of the context"]
    #[doc = ""]
    #[doc = " @param c           : the context to be deleted"]
    pub fn grib_context_delete(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Set the GTS header mode on."]
    #[doc = "  The GTS headers will be preserved."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn grib_gts_header_on(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Set the GTS header mode off."]
    #[doc = "  The GTS headers will be deleted."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn grib_gts_header_off(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Set the GRIBEX mode on."]
    #[doc = "  Grib files will be compatible with GRIBEX."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn grib_gribex_mode_on(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Get the GRIBEX mode."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn grib_get_gribex_mode(c: *mut grib_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set the GRIBEX mode off."]
    #[doc = "  GRIB files won't be always compatible with GRIBEX."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn grib_gribex_mode_off(c: *mut grib_context);
}
extern "C" {
    #[doc = " Sets the search path for definition files."]
    #[doc = ""]
    #[doc = " @param c      : the context to be modified"]
    #[doc = " @param path   : the search path for definition files"]
    pub fn grib_context_set_definitions_path(
        c: *mut grib_context,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sets the search path for sample files."]
    #[doc = ""]
    #[doc = " @param c      : the context to be modified"]
    #[doc = " @param path   : the search path for sample files"]
    pub fn grib_context_set_samples_path(c: *mut grib_context, path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "  Sets memory procedures of the context"]
    #[doc = ""]
    #[doc = " @param c           : the context to be modified"]
    #[doc = " @param griballoc   : the memory allocation procedure to be set @see grib_malloc_proc"]
    #[doc = " @param gribfree    : the memory freeing procedure to be set @see grib_free_proc"]
    pub fn grib_context_set_memory_proc(
        c: *mut grib_context,
        griballoc: grib_malloc_proc,
        gribfree: grib_free_proc,
        gribrealloc: grib_realloc_proc,
    );
}
extern "C" {
    #[doc = "  Sets memory procedures of the context for persistent data"]
    #[doc = ""]
    #[doc = " @param c           : the context to be modified"]
    #[doc = " @param griballoc   : the memory allocation procedure to be set @see grib_malloc_proc"]
    #[doc = " @param gribfree    : the memory freeing procedure to be set @see grib_free_proc"]
    pub fn grib_context_set_persistent_memory_proc(
        c: *mut grib_context,
        griballoc: grib_malloc_proc,
        gribfree: grib_free_proc,
    );
}
extern "C" {
    #[doc = "  Sets memory procedures of the context for large buffers"]
    #[doc = ""]
    #[doc = " @param c           : the context to be modified"]
    #[doc = " @param griballoc   : the memory allocation procedure to be set @see grib_malloc_proc"]
    #[doc = " @param gribfree    : the memory freeing procedure to be set @see grib_free_proc"]
    pub fn grib_context_set_buffer_memory_proc(
        c: *mut grib_context,
        griballoc: grib_malloc_proc,
        gribfree: grib_free_proc,
        gribrealloc: grib_realloc_proc,
    );
}
extern "C" {
    #[doc = "  Sets the context printing procedure used for user interaction"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    #[doc = " @param printp       : the printing procedure to be set @see grib_print_proc"]
    pub fn grib_context_set_print_proc(c: *mut grib_context, printp: grib_print_proc);
}
extern "C" {
    #[doc = "  Sets the context logging procedure used for system (warning, errors, infos ...) messages"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    #[doc = " @param logp         : the logging procedure to be set @see grib_log_proc"]
    pub fn grib_context_set_logging_proc(c: *mut grib_context, logp: grib_log_proc);
}
extern "C" {
    #[doc = "  Turn on support for multi-fields in single GRIB messages"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    pub fn grib_multi_support_on(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Turn off support for multi-fields in single GRIB messages"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    pub fn grib_multi_support_off(c: *mut grib_context);
}
extern "C" {
    #[doc = "  Reset file handle in multi-field support mode"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    #[doc = " @param f            : the file pointer"]
    pub fn grib_multi_support_reset_file(c: *mut grib_context, f: *mut FILE);
}
extern "C" {
    pub fn grib_samples_path(c: *const grib_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn grib_definition_path(c: *const grib_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the API version"]
    #[doc = ""]
    #[doc = "  @return        API version"]
    pub fn grib_get_api_version() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = "  Get the Git version control SHA1 identifier"]
    #[doc = ""]
    #[doc = "  @return character string with SHA1 identifier"]
    pub fn grib_get_git_sha1() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the package name"]
    #[doc = ""]
    #[doc = "  @return character string with package name"]
    pub fn grib_get_package_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Prints the API version"]
    pub fn grib_print_api_version(out: *mut FILE);
}
extern "C" {
    #[doc = " \\defgroup keys_iterator Iterating on keys names"]
    #[doc = "The keys iterator is designed to get the key names defined in a message."]
    #[doc = "Key names on which the iteration is carried out can be filtered through their"]
    #[doc = "attributes or by the namespace they belong to."]
    #[doc = "  @param h             : the handle whose keys you want to iterate"]
    #[doc = "  @param filter_flags  : flags to filter out some of the keys through their attributes"]
    #[doc = "  @param name_space    : if not null the iteration is carried out only on"]
    #[doc = "                         keys belonging to the namespace passed. (NULL for all the keys)"]
    #[doc = "  @return              keys iterator ready to iterate through keys according to filter_flags"]
    #[doc = "                       and namespace"]
    pub fn grib_keys_iterator_new(
        h: *mut grib_handle,
        filter_flags: ::std::os::raw::c_ulong,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut grib_keys_iterator;
}
extern "C" {
    pub fn codes_bufr_keys_iterator_new(
        h: *mut grib_handle,
        filter_flags: ::std::os::raw::c_ulong,
    ) -> *mut bufr_keys_iterator;
}
extern "C" {
    pub fn codes_bufr_data_section_keys_iterator_new(
        h: *mut grib_handle,
    ) -> *mut bufr_keys_iterator;
}
extern "C" {
    #[doc = " Step to the next iterator."]
    #[doc = "  @param kiter         : valid grib_keys_iterator"]
    #[doc = "  @return              1 if next iterator exists, 0 if no more elements to iterate on"]
    pub fn grib_keys_iterator_next(kiter: *mut grib_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_bufr_keys_iterator_next(kiter: *mut bufr_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the key name from the iterator"]
    #[doc = "  @param kiter         : valid grib_keys_iterator"]
    #[doc = "  @return              key name"]
    pub fn grib_keys_iterator_get_name(
        kiter: *const grib_keys_iterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn codes_bufr_keys_iterator_get_name(
        kiter: *const bufr_keys_iterator,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete the iterator."]
    #[doc = "  @param kiter         : valid grib_keys_iterator"]
    #[doc = "  @return              0 if OK, integer value on error"]
    pub fn grib_keys_iterator_delete(kiter: *mut grib_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_bufr_keys_iterator_delete(kiter: *mut bufr_keys_iterator)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rewind the iterator."]
    #[doc = "  @param kiter         : valid grib_keys_iterator"]
    #[doc = "  @return              0 if OK, integer value on error"]
    pub fn grib_keys_iterator_rewind(kiter: *mut grib_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_bufr_keys_iterator_rewind(kiter: *mut bufr_keys_iterator)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_keys_iterator_set_flags(
        kiter: *mut grib_keys_iterator,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_keys_iterator_get_long(
        kiter: *const grib_keys_iterator,
        v: *mut ::std::os::raw::c_long,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_keys_iterator_get_double(
        kiter: *const grib_keys_iterator,
        v: *mut f64,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_keys_iterator_get_string(
        kiter: *const grib_keys_iterator,
        v: *mut ::std::os::raw::c_char,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_keys_iterator_get_bytes(
        kiter: *const grib_keys_iterator,
        v: *mut ::std::os::raw::c_uchar,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_copy_key(
        h1: *mut grib_handle,
        h2: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_update_sections_lengths(h: *mut grib_handle);
}
extern "C" {
    #[doc = " Convert an error code into a string"]
    #[doc = " @param code       : the error code"]
    #[doc = " @return           the error message"]
    pub fn grib_get_error_message(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn grib_get_type_name(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn grib_get_native_type(
        h: *const grib_handle,
        name: *const ::std::os::raw::c_char,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_check(
        call: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        e: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn grib_set_values(
        h: *mut grib_handle,
        grib_values: *mut grib_values,
        arg_count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_handle_new_from_partial_message_copy(
        c: *mut grib_context,
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn grib_handle_new_from_partial_message(
        c: *mut grib_context,
        data: *const ::std::os::raw::c_void,
        buflen: size_t,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn grib_is_missing(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_is_defined(
        h: *const grib_handle,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_set_missing(
        h: *mut grib_handle,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_get_gaussian_latitudes(
        truncation: ::std::os::raw::c_long,
        latitudes: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_julian_to_datetime(
        jd: f64,
        year: *mut ::std::os::raw::c_long,
        month: *mut ::std::os::raw::c_long,
        day: *mut ::std::os::raw::c_long,
        hour: *mut ::std::os::raw::c_long,
        minute: *mut ::std::os::raw::c_long,
        second: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_datetime_to_julian(
        year: ::std::os::raw::c_long,
        month: ::std::os::raw::c_long,
        day: ::std::os::raw::c_long,
        hour: ::std::os::raw::c_long,
        minute: ::std::os::raw::c_long,
        second: ::std::os::raw::c_long,
        jd: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_julian_to_date(jdate: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn grib_date_to_julian(ddate: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn grib_get_reduced_row(
        pl: ::std::os::raw::c_long,
        lon_first: f64,
        lon_last: f64,
        npoints: *mut ::std::os::raw::c_long,
        ilon_first: *mut ::std::os::raw::c_long,
        ilon_last: *mut ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn grib_get_reduced_row_p(
        pl: ::std::os::raw::c_long,
        lon_first: f64,
        lon_last: f64,
        npoints: *mut ::std::os::raw::c_long,
        olon_first: *mut f64,
        olon_last: *mut f64,
    );
}
extern "C" {
    pub fn wmo_read_any_from_file(
        f: *mut FILE,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmo_read_grib_from_file(
        f: *mut FILE,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmo_read_bufr_from_file(
        f: *mut FILE,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmo_read_gts_from_file(
        f: *mut FILE,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmo_read_any_from_stream(
        stream_data: *mut ::std::os::raw::c_void,
        stream_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                buffer: *mut ::std::os::raw::c_void,
                len: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long,
        >,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmo_read_any_from_stream_malloc(
        stream_data: *mut ::std::os::raw::c_void,
        stream_proc: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                buffer: *mut ::std::os::raw::c_void,
                len: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long,
        >,
        size: *mut size_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmo_read_any_from_file_malloc(
        f: *mut FILE,
        headers_only: ::std::os::raw::c_int,
        size: *mut size_t,
        offset: *mut off_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmo_read_gts_from_file_malloc(
        f: *mut FILE,
        headers_only: ::std::os::raw::c_int,
        size: *mut size_t,
        offset: *mut off_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmo_read_bufr_from_file_malloc(
        f: *mut FILE,
        headers_only: ::std::os::raw::c_int,
        size: *mut size_t,
        offset: *mut off_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wmo_read_grib_from_file_malloc(
        f: *mut FILE,
        headers_only: ::std::os::raw::c_int,
        size: *mut size_t,
        offset: *mut off_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn grib_read_any_from_file(
        ctx: *mut grib_context,
        f: *mut FILE,
        buffer: *mut ::std::os::raw::c_void,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_get_message_offset(
        h: *const grib_handle,
        offset: *mut off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_get_message_size(h: *const grib_handle, size: *mut size_t)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_points {
    pub context: *mut grib_context,
    pub latitudes: *mut f64,
    pub longitudes: *mut f64,
    pub indexes: *mut size_t,
    pub group_start: *mut size_t,
    pub group_len: *mut size_t,
    pub n_groups: size_t,
    pub n: size_t,
    pub size: size_t,
}
extern "C" {
    pub fn grib_box_new(h: *mut grib_handle, error: *mut ::std::os::raw::c_int) -> *mut grib_box;
}
extern "C" {
    pub fn grib_box_get_points(
        box_: *mut grib_box,
        north: f64,
        west: f64,
        south: f64,
        east: f64,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_points;
}
extern "C" {
    pub fn grib_points_get_values(
        h: *mut grib_handle,
        points: *mut grib_points,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_util_grid_spec {
    pub grid_type: ::std::os::raw::c_int,
    pub Ni: ::std::os::raw::c_long,
    pub Nj: ::std::os::raw::c_long,
    pub iDirectionIncrementInDegrees: f64,
    pub jDirectionIncrementInDegrees: f64,
    pub longitudeOfFirstGridPointInDegrees: f64,
    pub longitudeOfLastGridPointInDegrees: f64,
    pub latitudeOfFirstGridPointInDegrees: f64,
    pub latitudeOfLastGridPointInDegrees: f64,
    pub uvRelativeToGrid: ::std::os::raw::c_long,
    pub latitudeOfSouthernPoleInDegrees: f64,
    pub longitudeOfSouthernPoleInDegrees: f64,
    pub iScansNegatively: ::std::os::raw::c_long,
    pub jScansPositively: ::std::os::raw::c_long,
    pub N: ::std::os::raw::c_long,
    pub bitmapPresent: ::std::os::raw::c_long,
    pub missingValue: f64,
    pub pl: *const ::std::os::raw::c_long,
    pub pl_size: ::std::os::raw::c_long,
    pub truncation: ::std::os::raw::c_long,
    pub orientationOfTheGridInDegrees: f64,
    pub DyInMetres: ::std::os::raw::c_long,
    pub DxInMetres: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grib_util_grid_spec2 {
    pub grid_type: ::std::os::raw::c_int,
    pub grid_name: *const ::std::os::raw::c_char,
    pub Ni: ::std::os::raw::c_long,
    pub Nj: ::std::os::raw::c_long,
    pub iDirectionIncrementInDegrees: f64,
    pub jDirectionIncrementInDegrees: f64,
    pub longitudeOfFirstGridPointInDegrees: f64,
    pub longitudeOfLastGridPointInDegrees: f64,
    pub latitudeOfFirstGridPointInDegrees: f64,
    pub latitudeOfLastGridPointInDegrees: f64,
    pub uvRelativeToGrid: ::std::os::raw::c_long,
    pub latitudeOfSouthernPoleInDegrees: f64,
    pub longitudeOfSouthernPoleInDegrees: f64,
    pub angleOfRotationInDegrees: f64,
    pub iScansNegatively: ::std::os::raw::c_long,
    pub jScansPositively: ::std::os::raw::c_long,
    pub N: ::std::os::raw::c_long,
    pub bitmapPresent: ::std::os::raw::c_long,
    pub missingValue: f64,
    pub pl: *const ::std::os::raw::c_long,
    pub pl_size: ::std::os::raw::c_long,
    pub truncation: ::std::os::raw::c_long,
    pub orientationOfTheGridInDegrees: f64,
    pub DyInMetres: ::std::os::raw::c_long,
    pub DxInMetres: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct grib_util_packing_spec {
    pub packing_type: ::std::os::raw::c_long,
    pub packing: ::std::os::raw::c_long,
    pub boustrophedonic: ::std::os::raw::c_long,
    pub editionNumber: ::std::os::raw::c_long,
    pub accuracy: ::std::os::raw::c_long,
    pub bitsPerValue: ::std::os::raw::c_long,
    pub decimalScaleFactor: ::std::os::raw::c_long,
    pub computeLaplacianOperator: ::std::os::raw::c_long,
    pub truncateLaplacian: ::std::os::raw::c_int,
    pub laplacianOperator: f64,
    pub deleteLocalDefinition: ::std::os::raw::c_long,
    pub extra_settings: [grib_values; 80usize],
    pub extra_settings_count: ::std::os::raw::c_long,
}
extern "C" {
    pub fn grib_util_set_spec(
        h: *mut grib_handle,
        grid_spec: *const grib_util_grid_spec,
        packing_spec: *const grib_util_packing_spec,
        flags: ::std::os::raw::c_int,
        data_values: *const f64,
        data_values_count: size_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn grib_util_set_spec2(
        h: *mut grib_handle,
        grid_spec: *const grib_util_grid_spec2,
        packing_spec: *const grib_util_packing_spec,
        flags: ::std::os::raw::c_int,
        data_values: *const f64,
        data_values_count: size_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
extern "C" {
    pub fn parse_keyval_string(
        grib_tool: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_char,
        values_required: ::std::os::raw::c_int,
        default_type: ::std::os::raw::c_int,
        values: *mut grib_values,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grib_new_from_file(
        c: *mut grib_context,
        f: *mut FILE,
        headers_only: ::std::os::raw::c_int,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut grib_handle;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct codes_bufr_header {
    pub message_offset: ::std::os::raw::c_ulong,
    pub message_size: ::std::os::raw::c_ulong,
    pub edition: ::std::os::raw::c_long,
    pub masterTableNumber: ::std::os::raw::c_long,
    pub bufrHeaderSubCentre: ::std::os::raw::c_long,
    pub bufrHeaderCentre: ::std::os::raw::c_long,
    pub updateSequenceNumber: ::std::os::raw::c_long,
    pub dataCategory: ::std::os::raw::c_long,
    pub dataSubCategory: ::std::os::raw::c_long,
    pub masterTablesVersionNumber: ::std::os::raw::c_long,
    pub localTablesVersionNumber: ::std::os::raw::c_long,
    pub typicalYear: ::std::os::raw::c_long,
    pub typicalMonth: ::std::os::raw::c_long,
    pub typicalDay: ::std::os::raw::c_long,
    pub typicalHour: ::std::os::raw::c_long,
    pub typicalMinute: ::std::os::raw::c_long,
    pub typicalSecond: ::std::os::raw::c_long,
    pub typicalDate: ::std::os::raw::c_long,
    pub typicalTime: ::std::os::raw::c_long,
    pub internationalDataSubCategory: ::std::os::raw::c_long,
    pub localSectionPresent: ::std::os::raw::c_long,
    pub ecmwfLocalSectionPresent: ::std::os::raw::c_long,
    pub rdbType: ::std::os::raw::c_long,
    pub oldSubtype: ::std::os::raw::c_long,
    pub rdbSubtype: ::std::os::raw::c_long,
    pub ident: [::std::os::raw::c_char; 9usize],
    pub localYear: ::std::os::raw::c_long,
    pub localMonth: ::std::os::raw::c_long,
    pub localDay: ::std::os::raw::c_long,
    pub localHour: ::std::os::raw::c_long,
    pub localMinute: ::std::os::raw::c_long,
    pub localSecond: ::std::os::raw::c_long,
    pub rdbtimeDay: ::std::os::raw::c_long,
    pub rdbtimeHour: ::std::os::raw::c_long,
    pub rdbtimeMinute: ::std::os::raw::c_long,
    pub rdbtimeSecond: ::std::os::raw::c_long,
    pub rectimeDay: ::std::os::raw::c_long,
    pub rectimeHour: ::std::os::raw::c_long,
    pub rectimeMinute: ::std::os::raw::c_long,
    pub rectimeSecond: ::std::os::raw::c_long,
    pub restricted: ::std::os::raw::c_long,
    pub isSatellite: ::std::os::raw::c_long,
    pub localLongitude1: f64,
    pub localLatitude1: f64,
    pub localLongitude2: f64,
    pub localLatitude2: f64,
    pub localLatitude: f64,
    pub localLongitude: f64,
    pub localNumberOfObservations: ::std::os::raw::c_long,
    pub satelliteID: ::std::os::raw::c_long,
    pub qualityControl: ::std::os::raw::c_long,
    pub newSubtype: ::std::os::raw::c_long,
    pub daLoop: ::std::os::raw::c_long,
    pub numberOfSubsets: ::std::os::raw::c_ulong,
    pub observedData: ::std::os::raw::c_long,
    pub compressedData: ::std::os::raw::c_long,
}
pub type codes_assertion_failed_proc =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn codes_set_codes_assertion_failed_proc(proc_: codes_assertion_failed_proc);
}
pub type codes_values = grib_values;
pub type codes_key_value_list = grib_key_value_list;
#[doc = " Codes handle,   structure giving access to parsed values by keys"]
#[doc = "\\ingroup codes_handle"]
#[doc = "\\struct codes_handle"]
pub type codes_handle = grib_handle;
#[doc = " GRIB multi-field handle, structure used to build multi-field messages."]
#[doc = "\\ingroup codes_handle"]
#[doc = "\\struct codes_multi_handle"]
pub type codes_multi_handle = grib_multi_handle;
#[doc = " Codes context,  structure containing the memory methods, the parsers and the formats."]
#[doc = "\\ingroup codes_context"]
#[doc = "\\struct codes_context"]
pub type codes_context = grib_context;
#[doc = " GRIB geoiterator, structure supporting a geographic iteration of values in a GRIB message."]
#[doc = "\\ingroup iterators"]
#[doc = "\\struct codes_iterator"]
pub type codes_iterator = grib_iterator;
#[doc = " Codes nearest, structure used to find the nearest points of a latitude longitude point in a GRIB message."]
#[doc = "\\ingroup iterators"]
#[doc = "\\struct codes_nearest"]
pub type codes_nearest = grib_nearest;
pub type codes_box = grib_box;
pub type codes_points = grib_points;
#[doc = " Codes keys iterator. Iterator over keys."]
#[doc = "\\ingroup keys_iterator"]
#[doc = "\\struct codes_keys_iterator"]
pub type codes_keys_iterator = grib_keys_iterator;
pub type codes_bufr_keys_iterator = bufr_keys_iterator;
pub type codes_fieldset = grib_fieldset;
pub type codes_order_by = grib_order_by;
pub type codes_where = grib_where;
pub type codes_sarray = grib_sarray;
pub type codes_oarray = grib_oarray;
pub type codes_darray = grib_darray;
pub type codes_iarray = grib_iarray;
pub type codes_vdarray = grib_vdarray;
pub type codes_vsarray = grib_vsarray;
pub type codes_viarray = grib_viarray;
pub type codes_string_list = grib_string_list;
pub type codes_util_packing_spec = grib_util_packing_spec;
pub type codes_util_grid_spec = grib_util_grid_spec;
extern "C" {
    pub fn codes_fieldset_new_from_files(
        c: *mut codes_context,
        filenames: *mut *mut ::std::os::raw::c_char,
        nfiles: ::std::os::raw::c_int,
        keys: *mut *mut ::std::os::raw::c_char,
        nkeys: ::std::os::raw::c_int,
        where_string: *const ::std::os::raw::c_char,
        order_by_string: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_fieldset;
}
extern "C" {
    pub fn codes_fieldset_delete(set: *mut codes_fieldset);
}
extern "C" {
    pub fn codes_fieldset_rewind(set: *mut codes_fieldset);
}
extern "C" {
    pub fn codes_fieldset_apply_order_by(
        set: *mut codes_fieldset,
        order_by_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_fieldset_next_handle(
        set: *mut codes_fieldset,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    pub fn codes_fieldset_count(set: *mut codes_fieldset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_values_check(
        h: *mut codes_handle,
        values: *mut codes_values,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " index structure to access messages in a file."]
#[doc = " \\ingroup codes_index"]
#[doc = " \\struct codes_index"]
pub type codes_index = grib_index;
extern "C" {
    #[doc = "  Create a new index form a file. The file is indexed with the keys in argument."]
    #[doc = ""]
    #[doc = " @param c           : context  (NULL for default context)"]
    #[doc = " @param filename    : name of the file of messages to be indexed"]
    #[doc = " @param keys        : comma separated list of keys for the index."]
    #[doc = "    The type of the key can be explicitly declared appending :l for long,"]
    #[doc = "    (or alternatively :i)"]
    #[doc = "    :d for double, :s for string to the key name. If the type is not"]
    #[doc = "    declared explicitly, the native type is assumed."]
    #[doc = " @param err         :  0 if OK, integer value on error"]
    #[doc = " @return            the newly created index"]
    pub fn codes_index_new_from_file(
        c: *mut codes_context,
        filename: *const ::std::os::raw::c_char,
        keys: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_index;
}
extern "C" {
    #[doc = "  Create a new index based on a set of keys."]
    #[doc = ""]
    #[doc = " @param c           : context  (NULL for default context)"]
    #[doc = " @param keys        : comma separated list of keys for the index."]
    #[doc = "    The type of the key can be explicitly declared appending :l for long,"]
    #[doc = "    (or alternatively :i)"]
    #[doc = "    :d for double, :s for string to the key name. If the type is not"]
    #[doc = "    declared explicitly, the native type is assumed."]
    #[doc = " @param err         :  0 if OK, integer value on error"]
    #[doc = " @return            the newly created index"]
    pub fn codes_index_new(
        c: *mut codes_context,
        keys: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_index;
}
extern "C" {
    #[doc = "  Indexes the file given in argument in the index given in argument."]
    #[doc = ""]
    #[doc = " @param index       : index"]
    #[doc = " @param filename    : name of the file of messages to be indexed"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_add_file(
        index: *mut codes_index,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_index_write(
        index: *mut codes_index,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_index_read(
        c: *mut codes_context,
        filename: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_index;
}
extern "C" {
    #[doc = "  Get the number of distinct values of the key in argument contained in the index. The key must belong to the index."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the number of values is computed"]
    #[doc = " @param size        : number of distinct values of the key in the index"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_get_size(
        index: *const codes_index,
        key: *const ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as long or when the native type of the key is long."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_get_long(
        index: *const codes_index,
        key: *const ::std::os::raw::c_char,
        values: *mut ::std::os::raw::c_long,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as double or when the native type of the key is double."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_get_double(
        index: *const codes_index,
        key: *const ::std::os::raw::c_char,
        values: *mut f64,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the distinct values of the key in argument contained in the index. The key must belong to the index. This function is used when the type of the key was explicitly defined as string or when the native type of the key is string."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key for which the values are returned"]
    #[doc = " @param values      : array of values. The array must be allocated before entering this function and its size must be enough to contain all the values."]
    #[doc = " @param size        : size of the values array"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_get_string(
        index: *const codes_index,
        key: *const ::std::os::raw::c_char,
        values: *mut *mut ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Select the message subset with key==value. The value is a long. The key must have been created with long type or have long as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_select_long(
        index: *mut codes_index,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Select the message subset with key==value. The value is a double. The key must have been created with double type or have double as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_select_double(
        index: *mut codes_index,
        key: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select the message subset with key==value. The value is a string. The key must have been created with string type or have string as native type if the type was not explicitly defined in the index creation."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = "     The index must have been created with the key in argument."]
    #[doc = " @param key         : key to be selected"]
    #[doc = " @param value       : value of the key to select"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_index_select_string(
        index: *mut codes_index,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new handle from an index after having selected the key values."]
    #[doc = " All the keys belonging to the index must be selected before calling this function. Successive calls to this function will return all the handles compatible with the constraints defined selecting the values of the index keys."]
    #[doc = " When no more handles are available from the index a NULL pointer is returned and the err variable is set to CODES_END_OF_INDEX."]
    #[doc = ""]
    #[doc = " @param index       : an index created from a file."]
    #[doc = " @param err         : 0 if OK, integer value on error. CODES_END_OF_INDEX when no more handles are contained in the index."]
    #[doc = " @return            GRIB handle."]
    pub fn codes_handle_new_from_index(
        index: *mut codes_index,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Delete the index."]
    #[doc = ""]
    #[doc = " @param index       : index to be deleted."]
    pub fn codes_index_delete(index: *mut codes_index);
}
extern "C" {
    #[doc = " \\defgroup codes_handle The message handle"]
    #[doc = "The codes_handle is the structure giving access to parsed message values by keys."]
    #[doc = "  Counts the messages contained in a file resource."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param n           : the number of messages in the file"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_count_in_file(
        c: *mut codes_context,
        f: *mut FILE,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Counts the messages contained in a file."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param filename    : the path to the file"]
    #[doc = " @param n           : the number of messages in the file"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_count_in_filename(
        c: *mut codes_context,
        filename: *const ::std::os::raw::c_char,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Create a handle from a file resource."]
    #[doc = "  The file is read until a message is found. The message is then copied."]
    #[doc = "  Remember always to delete the handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param product     : the kind of product e.g. PRODUCT_GRIB, PRODUCT_BUFR"]
    #[doc = " @param error       : error code set if the returned handle is NULL and the end of file is not reached"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn codes_handle_new_from_file(
        c: *mut codes_context,
        f: *mut FILE,
        product: ProductKind,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a GRIB handle from a file resource."]
    #[doc = "  The file is read until a GRIB message is found. The message is then copied."]
    #[doc = "  Remember always to delete the handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param error       : error code set if the returned handle is NULL and the end of file is not reached"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn codes_grib_handle_new_from_file(
        c: *mut codes_context,
        f: *mut FILE,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a BUFR handle from a file resource."]
    #[doc = "  The file is read until a BUFR message is found. The message is then copied."]
    #[doc = "  Remember always to delete the handle when it is not needed anymore to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param f           : the file resource"]
    #[doc = " @param error       : error code set if the returned handle is NULL and the end of file is not reached"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn codes_bufr_handle_new_from_file(
        c: *mut codes_context,
        f: *mut FILE,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Write a coded message to a file."]
    #[doc = ""]
    #[doc = " @param h           : codes_handle to be written"]
    #[doc = " @param file        : name of the output file"]
    #[doc = " @param mode        : mode"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_write_message(
        h: *const codes_handle,
        file: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_grib_util_sections_copy(
        hfrom: *mut codes_handle,
        hto: *mut codes_handle,
        what: ::std::os::raw::c_int,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    pub fn codes_grib_util_get_param_id(
        mars_param: *const ::std::os::raw::c_char,
    ) -> *mut codes_string_list;
}
extern "C" {
    pub fn codes_grib_util_get_mars_param(
        param_id: *const ::std::os::raw::c_char,
    ) -> *mut codes_string_list;
}
extern "C" {
    #[doc = "  Create a handle from a user message in memory. The message will not be freed at the end."]
    #[doc = "  The message will be copied as soon as a modification is needed."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn codes_handle_new_from_message(
        c: *mut codes_context,
        data: *const ::std::os::raw::c_void,
        data_len: size_t,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a handle from a user message in memory. The message will not be freed at the end."]
    #[doc = "  The message will be copied as soon as a modification is needed."]
    #[doc = "  This function works also with multi-field messages."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @param error       : error code"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn codes_grib_handle_new_from_multi_message(
        c: *mut codes_context,
        data: *mut *mut ::std::os::raw::c_void,
        data_len: *mut size_t,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a handle from a user message. The message is copied and will be freed with the handle"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param data        : the actual message"]
    #[doc = " @param data_len    : the length of the message in number of bytes"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn codes_handle_new_from_message_copy(
        c: *mut codes_context,
        data: *const ::std::os::raw::c_void,
        data_len: size_t,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a handle from a GRIB message contained in the samples directory."]
    #[doc = "  The message is copied at the creation of the handle"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param sample_name : the name of the sample file (without the .tmpl extension)"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn codes_grib_handle_new_from_samples(
        c: *mut codes_context,
        sample_name: *const ::std::os::raw::c_char,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Create a handle from a BUFR message contained in a samples directory."]
    #[doc = "  The message is copied at the creation of the handle"]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    #[doc = " @param sample_name : the name of the sample file (without the .tmpl extension)"]
    #[doc = " @return            the new handle, NULL if the resource is invalid or a problem is encountered"]
    pub fn codes_bufr_handle_new_from_samples(
        c: *mut codes_context,
        sample_name: *const ::std::os::raw::c_char,
    ) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Clone an existing handle using the context of the original handle,"]
    #[doc = "  The message is copied and reparsed"]
    #[doc = ""]
    #[doc = " @param h           : The handle to be cloned"]
    #[doc = " @return            the new handle, NULL if the message is invalid or a problem is encountered"]
    pub fn codes_handle_clone(h: *const codes_handle) -> *mut codes_handle;
}
extern "C" {
    #[doc = "  Frees a handle, also frees the message if it is not a user message"]
    #[doc = "  @see  codes_handle_new_from_message"]
    #[doc = " @param h           : The handle to be deleted"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_handle_delete(h: *mut codes_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Create an empty multi-field GRIB handle."]
    #[doc = "  This is only applicable to GRIB edition 2."]
    #[doc = "  Remember always to delete the multi-handle when it is not needed any more to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param c           : the context from which the handle will be created (NULL for default context)"]
    pub fn codes_grib_multi_handle_new(c: *mut codes_context) -> *mut codes_multi_handle;
}
extern "C" {
    #[doc = "  Append the sections starting with start_section of the message pointed by h at"]
    #[doc = "  the end of the multi-field GRIB handle mh."]
    #[doc = "  This is only applicable to GRIB edition 2."]
    #[doc = "  Remember always to delete the multi-handle when it is not needed any more to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param h           : The handle from which the sections are copied."]
    #[doc = " @param start_section : Section number. Starting from this section all the sections to the end of the message will be copied."]
    #[doc = " @param mh          : The multi-field handle on which the sections are appended."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_multi_handle_append(
        h: *mut codes_handle,
        start_section: ::std::os::raw::c_int,
        mh: *mut codes_multi_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete multi-field GRIB handle."]
    #[doc = " This is only applicable to GRIB edition 2."]
    #[doc = ""]
    #[doc = " @param mh          : The multi-field handle to be deleted."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_multi_handle_delete(mh: *mut codes_multi_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Write a multi-field GRIB handle in a file."]
    #[doc = "  This is only applicable to GRIB edition 2."]
    #[doc = "  Remember always to delete the multi-handle when it is not needed any more to avoid"]
    #[doc = "  memory leaks."]
    #[doc = ""]
    #[doc = " @param mh          : The multi-field GRIB handle to be written."]
    #[doc = " @param f            : File on which the file handle is written."]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_multi_handle_write(
        mh: *mut codes_multi_handle,
        f: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup handling_coded_messages Handling coded messages */"]
    #[doc = " getting the message attached to a handle"]
    #[doc = ""]
    #[doc = " @param h              : the handle to which the buffer should be gathered"]
    #[doc = " @param message        : the pointer to be set to the handle's data"]
    #[doc = " @param message_length : On exit, the message size in number of bytes"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_message(
        h: *const codes_handle,
        message: *mut *const ::std::os::raw::c_void,
        message_length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " getting a copy of the message attached to a handle"]
    #[doc = ""]
    #[doc = " @param h              : the handle to which the buffer should be returned"]
    #[doc = " @param message        : the pointer to the data buffer to be filled"]
    #[doc = " @param message_length : On entry, the size in number of bytes of the allocated empty message."]
    #[doc = "                         On exit, the actual message length in number of bytes"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_message_copy(
        h: *const codes_handle,
        message: *mut ::std::os::raw::c_void,
        message_length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new geoiterator from a GRIB handle, using current geometry and values."]
    #[doc = ""]
    #[doc = " \\param h           : the handle from which the geoiterator will be created"]
    #[doc = " \\param flags       : flags for future use."]
    #[doc = " \\param error       : error code"]
    #[doc = " \\return            the new geoiterator, NULL if no geoiterator can be created"]
    pub fn codes_grib_iterator_new(
        h: *const codes_handle,
        flags: ::std::os::raw::c_ulong,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_iterator;
}
extern "C" {
    #[doc = " Get latitude/longitude and data values."]
    #[doc = " The Latitudes, longitudes and values arrays must be properly allocated by the caller."]
    #[doc = " Their required dimension can be obtained by getting the value of the integer key \"numberOfPoints\"."]
    #[doc = ""]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param lats        : returned array of latitudes"]
    #[doc = " @param lons        : returned array of longitudes"]
    #[doc = " @param values      : returned array of data values"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_get_data(
        h: *const codes_handle,
        lats: *mut f64,
        lons: *mut f64,
        values: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next value from a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @param lat         : on output latitude in degree"]
    #[doc = " @param lon         : on output longitude in degree"]
    #[doc = " @param value       : on output value of the point"]
    #[doc = " @return            positive value if successful, 0 if no more data are available"]
    pub fn codes_grib_iterator_next(
        i: *mut codes_iterator,
        lat: *mut f64,
        lon: *mut f64,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the previous value from a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @param lat         : on output latitude in degree"]
    #[doc = " @param lon         : on output longitude in degree"]
    #[doc = " @param value       : on output value of the point*"]
    #[doc = " @return            positive value if successful, 0 if no more data are available"]
    pub fn codes_grib_iterator_previous(
        i: *mut codes_iterator,
        lat: *mut f64,
        lon: *mut f64,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test procedure for values in a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            boolean, 1 if the iterator still nave next values, 0 otherwise"]
    pub fn codes_grib_iterator_has_next(i: *mut codes_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test procedure for values in a geoiterator."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_iterator_reset(i: *mut codes_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Frees the geoiterator from memory."]
    #[doc = ""]
    #[doc = " @param i           : the geoiterator"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_iterator_delete(i: *mut codes_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Create a new nearest neighbour object from a handle, using current geometry."]
    #[doc = ""]
    #[doc = " \\param h           : the handle from which the nearest object will be created"]
    #[doc = " \\param error       : error code"]
    #[doc = " \\return            the new nearest, NULL if no nearest can be created"]
    pub fn codes_grib_nearest_new(
        h: *const codes_handle,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut codes_nearest;
}
extern "C" {
    #[doc = " Find the 4 nearest points of a latitude longitude point."]
    #[doc = " The flags are provided to speed up the process of searching. If you are"]
    #[doc = " sure that the point you are asking for is not changing from a call"]
    #[doc = " to another you can use CODES_NEAREST_SAME_POINT. The same is valid for"]
    #[doc = " the grid. Flags can be used together doing a bitwise OR."]
    #[doc = " The distances are given in kilometres."]
    #[doc = ""]
    #[doc = " @param nearest     : nearest structure"]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param inlat       : latitude of the point to search for"]
    #[doc = " @param inlon       : longitude of the point to search for"]
    #[doc = " @param flags       : CODES_NEAREST_SAME_POINT, CODES_NEAREST_SAME_GRID"]
    #[doc = " @param outlats     : returned array of latitudes of the nearest points"]
    #[doc = " @param outlons     : returned array of longitudes of the nearest points"]
    #[doc = " @param values      : returned array of data values of the nearest points"]
    #[doc = " @param distances   : returned array of distances from the nearest points"]
    #[doc = " @param indexes     : returned array of indexes of the nearest points"]
    #[doc = " @param len         : size of the arrays"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_nearest_find(
        nearest: *mut codes_nearest,
        h: *const codes_handle,
        inlat: f64,
        inlon: f64,
        flags: ::std::os::raw::c_ulong,
        outlats: *mut f64,
        outlons: *mut f64,
        values: *mut f64,
        distances: *mut f64,
        indexes: *mut ::std::os::raw::c_int,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Frees an nearest from memory"]
    #[doc = ""]
    #[doc = " @param nearest           : the nearest"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_nearest_delete(nearest: *mut codes_nearest) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find the nearest point of a set of points whose latitudes and longitudes"]
    #[doc = " are given in the inlats, inlons arrays respectively."]
    #[doc = " If the flag is_lsm is 1 the nearest land point is returned and the"]
    #[doc = " GRIB passed as handle (h) is considered a land sea mask."]
    #[doc = " The land nearest point is the nearest point with land sea mask value>=0.5."]
    #[doc = " If no nearest land points are found the nearest value is returned."]
    #[doc = " If the flag is_lsm is 0 the nearest point is returned."]
    #[doc = " values, distances, indexes (in the \"values\" array) for the nearest points (ilons,ilats)"]
    #[doc = " are returned."]
    #[doc = " The distances are given in kilometres."]
    #[doc = ""]
    #[doc = " @param h           : handle from which geography and data values are taken"]
    #[doc = " @param is_lsm      : lsm flag (1-> nearest land, 0-> nearest)"]
    #[doc = " @param inlats      : latitudes of the points to search for"]
    #[doc = " @param inlons      : longitudes of the points to search for"]
    #[doc = " @param npoints     : number of points (size of the inlats,inlons,outlats,outlons,values,distances,indexes arrays)"]
    #[doc = " @param outlats     : returned array of latitudes of the nearest points"]
    #[doc = " @param outlons     : returned array of longitudes of the nearest points"]
    #[doc = " @param values      : returned array of data values of the nearest points"]
    #[doc = " @param distances   : returned array of distances from the nearest points"]
    #[doc = " @param indexes     : returned array of indexes of the nearest points"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_grib_nearest_find_multiple(
        h: *const codes_handle,
        is_lsm: ::std::os::raw::c_int,
        inlats: *const f64,
        inlons: *const f64,
        npoints: ::std::os::raw::c_long,
        outlats: *mut f64,
        outlons: *mut f64,
        values: *mut f64,
        distances: *mut f64,
        indexes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup get_set Accessing header and data values   */"]
    #[doc = "  Get the number offset of a key, in a message if several keys of the same name"]
    #[doc = "  are present, the offset of the last one is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param offset      : the address of a size_t where the offset will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_offset(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the number of coded value from a key, if several keys of the same name are present, the total sum is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param size        : the address of a size_t where the size will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_size(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get the length of the string representation of the key, if several keys of the same name are present, the maximum length is returned"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the offset from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param length        : the address of a size_t where the length will be set"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_length(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a long value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = "  @see  codes_set_long"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param value       : the address of a long where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_long(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a double value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = "  @see  codes_set_double"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param value       : the address of a double where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_double(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get as double the i-th element of the \"key\" array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param i           : zero-based index"]
    #[doc = " @param value       : the address of a double where the data will be retrieved"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_double_element(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get as double array the elements of the \"key\" array whose indexes are listed in the input array i"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param i           : zero-based array of indexes"]
    #[doc = " @param size        : size of the i and value arrays"]
    #[doc = " @param value       : the double array for the data values"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_double_elements(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        i: *mut ::std::os::raw::c_int,
        size: ::std::os::raw::c_long,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get a string value from a key, if several keys of the same name are present, the last one is returned"]
    #[doc = " @see  codes_set_string"]
    #[doc = ""]
    #[doc = " @param h         : the handle to get the data from"]
    #[doc = " @param key       : the key to be searched"]
    #[doc = " @param mesg      : the address of a string where the data will be retrieved"]
    #[doc = " @param length    : the address of a size_t that contains allocated length of the string on input, and that contains the actual length of the string on output"]
    #[doc = " @return          0 if OK, integer value on error"]
    pub fn codes_get_string(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        mesg: *mut ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get string array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  codes_set_string_array"]
    #[doc = ""]
    #[doc = " @param h       : the handle to get the data from"]
    #[doc = " @param key     : the key to be searched"]
    #[doc = " @param vals    : the address of a string array where the data will be retrieved"]
    #[doc = " @param length  : the address of a size_t that contains allocated length of the array on input, and that contains the actual length of the array on output"]
    #[doc = " @return        0 if OK, integer value on error"]
    pub fn codes_get_string_array(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut *mut ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get raw bytes values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  codes_set_bytes"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param bytes       : the address of a byte array where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the byte array on input, and that contains the actual length of the byte array on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_bytes(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        bytes: *mut ::std::os::raw::c_uchar,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get double array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  codes_set_double_array"]
    #[doc = ""]
    #[doc = " @param h        : the handle to get the data from"]
    #[doc = " @param key      : the key to be searched"]
    #[doc = " @param vals     : the address of a double array where the data will be retrieved"]
    #[doc = " @param length   : the address of a size_t that contains allocated length of the double array on input, and that contains the actual length of the double array on output"]
    #[doc = " @return         0 if OK, integer value on error"]
    pub fn codes_get_double_array(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut f64,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Get long array values from a key. If several keys of the same name are present, the last one is returned"]
    #[doc = " @see  codes_set_long_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to get the data from"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals       : the address of a long array where the data will be retrieved"]
    #[doc = " @param length      : the address of a size_t that contains allocated length of the long array on input, and that contains the actual length of the long array on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_get_long_array(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut ::std::os::raw::c_long,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Copy the keys belonging to a given namespace from a source handle to a destination handle"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param dest      : destination handle"]
    #[doc = " @param name      : namespace"]
    #[doc = " @param src       : source handle"]
    #[doc = " @return          0 if OK, integer value on error"]
    pub fn codes_copy_namespace(
        dest: *mut codes_handle,
        name: *const ::std::os::raw::c_char,
        src: *mut codes_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a long value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_long"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param val         : a long where the data will be read"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_long(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a double value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_double"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param val       : a double where the data will be read"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_double(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a string value from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_string"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param mesg       : the address of a string where the data will be read"]
    #[doc = " @param length      : the address of a size_t that contains the length of the string on input, and that contains the actual packed length of the string on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_string(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        mesg: *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a bytes array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_bytes"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param bytes       : the address of a byte array where the data will be read"]
    #[doc = " @param length      : the address of a size_t that contains the length of the byte array on input, and that contains the actual packed length of the byte array  on output"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_bytes(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        bytes: *const ::std::os::raw::c_uchar,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a double array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "   @see  codes_get_double_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a double array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the byte array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_double_array(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const f64,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as codes_set_double_array but allows setting of READ-ONLY keys like codedValues."]
    #[doc = " Use with great caution!!"]
    pub fn codes_set_force_double_array(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const f64,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a long array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_long_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a long array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the long array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_long_array(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *const ::std::os::raw::c_long,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a string array from a key. If several keys of the same name are present, the last one is set"]
    #[doc = "  @see  codes_get_long_array"]
    #[doc = ""]
    #[doc = " @param h           : the handle to set the data to"]
    #[doc = " @param key         : the key to be searched"]
    #[doc = " @param vals        : the address of a string array where the data will be read"]
    #[doc = " @param length      : a size_t that contains the length of the array on input"]
    #[doc = " @return            0 if OK, integer value on error"]
    pub fn codes_set_string_array(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
        vals: *mut *const ::std::os::raw::c_char,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Print all keys, with the context print procedure and dump mode to a resource"]
    #[doc = ""]
    #[doc = " @param h            : the handle to be printed"]
    #[doc = " @param out          : output file handle"]
    #[doc = " @param mode         : Examples of available dump modes: debug wmo"]
    #[doc = " @param option_flags : all the CODES_DUMP_FLAG_x flags can be used"]
    #[doc = " @param arg          : used to provide a format to output data (experimental)"]
    pub fn codes_dump_content(
        h: *const codes_handle,
        out: *mut FILE,
        mode: *const ::std::os::raw::c_char,
        option_flags: ::std::os::raw::c_ulong,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "  Print all keys from the parsed definition files available in a context"]
    #[doc = ""]
    #[doc = " @param f           : the File used to print the keys on"]
    #[doc = " @param c           : the context that contains the cached definition files to be printed"]
    pub fn codes_dump_action_tree(c: *mut codes_context, f: *mut FILE);
}
extern "C" {
    #[doc = "  Get the static default context"]
    #[doc = ""]
    #[doc = " @return            the default context, NULL it the context is not available"]
    pub fn codes_context_get_default() -> *mut codes_context;
}
extern "C" {
    #[doc = "  Frees the cached definition files of the context"]
    #[doc = ""]
    #[doc = " @param c           : the context to be deleted"]
    pub fn codes_context_delete(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Set the GTS header mode on."]
    #[doc = "  The GTS headers will be preserved."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn codes_gts_header_on(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Set the GTS header mode off."]
    #[doc = "  The GTS headers will be deleted."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn codes_gts_header_off(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Set the GRIBEX mode on."]
    #[doc = "  GRIB files will be compatible with GRIBEX."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn codes_gribex_mode_on(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Get the GRIBEX mode."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn codes_get_gribex_mode(c: *mut codes_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set the GRIBEX mode off."]
    #[doc = "  GRIB files won't be always compatible with GRIBEX."]
    #[doc = ""]
    #[doc = " @param c           : the context"]
    pub fn codes_gribex_mode_off(c: *mut codes_context);
}
extern "C" {
    pub fn codes_bufr_multi_element_constant_arrays_on(c: *mut codes_context);
}
extern "C" {
    pub fn codes_bufr_multi_element_constant_arrays_off(c: *mut codes_context);
}
extern "C" {
    #[doc = " Sets the search path for definition files."]
    #[doc = ""]
    #[doc = " @param c      : the context to be modified"]
    #[doc = " @param path   : the search path for definition files"]
    pub fn codes_context_set_definitions_path(
        c: *mut codes_context,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sets the search path for sample files."]
    #[doc = ""]
    #[doc = " @param c      : the context to be modified"]
    #[doc = " @param path   : the search path for sample files"]
    pub fn codes_context_set_samples_path(
        c: *mut codes_context,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "  Turn on support for multi-fields in single GRIB messages"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    pub fn codes_grib_multi_support_on(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Turn off support for multi-fields in single GRIB messages"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    pub fn codes_grib_multi_support_off(c: *mut codes_context);
}
extern "C" {
    #[doc = "  Reset file handle in multiple GRIB field support mode"]
    #[doc = ""]
    #[doc = " @param c            : the context to be modified"]
    #[doc = " @param f            : the file pointer"]
    pub fn codes_grib_multi_support_reset_file(c: *mut codes_context, f: *mut FILE);
}
extern "C" {
    pub fn codes_samples_path(c: *const codes_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn codes_definition_path(c: *const codes_context) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the API version"]
    #[doc = ""]
    #[doc = "  @return API version"]
    pub fn codes_get_api_version() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = "  Get the Git version control SHA1 identifier"]
    #[doc = ""]
    #[doc = "  @return character string with SHA1 identifier"]
    pub fn codes_get_git_sha1() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Get the package name"]
    #[doc = ""]
    #[doc = "  @return character string with package name"]
    pub fn codes_get_package_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  Prints the API version"]
    pub fn codes_print_api_version(out: *mut FILE);
}
extern "C" {
    #[doc = " \\defgroup keys_iterator Iterating on keys names"]
    #[doc = "The keys iterator is designed to get the key names defined in a message."]
    #[doc = "Key names on which the iteration is carried out can be filtered through their"]
    #[doc = "attributes or by the namespace they belong to."]
    #[doc = "  @param h             : the handle whose keys you want to iterate"]
    #[doc = "  @param filter_flags  : flags to filter out some of the keys through their attributes"]
    #[doc = "  @param name_space    : if not null the iteration is carried out only on"]
    #[doc = "                         keys belonging to the namespace passed. (NULL for all the keys)"]
    #[doc = "  @return              keys iterator ready to iterate through keys according to filter_flags"]
    #[doc = "                       and namespace"]
    pub fn codes_keys_iterator_new(
        h: *mut codes_handle,
        filter_flags: ::std::os::raw::c_ulong,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut codes_keys_iterator;
}
extern "C" {
    pub fn codes_bufr_copy_data_return_copied_keys(
        hin: *mut codes_handle,
        hout: *mut codes_handle,
        nkeys: *mut size_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn codes_bufr_copy_data(
        hin: *mut codes_handle,
        hout: *mut codes_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Step to the next item from the keys iterator."]
    #[doc = "  @param kiter         : valid codes_keys_iterator"]
    #[doc = "  @return              1 if next iterator exists, 0 if no more elements to iterate on"]
    pub fn codes_keys_iterator_next(kiter: *mut codes_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the key name from the keys iterator"]
    #[doc = "  @param kiter         : valid codes_keys_iterator"]
    #[doc = "  @return              key name"]
    pub fn codes_keys_iterator_get_name(
        kiter: *const codes_keys_iterator,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete the keys iterator."]
    #[doc = "  @param kiter         : valid codes_keys_iterator"]
    #[doc = "  @return              0 if OK, integer value on error"]
    pub fn codes_keys_iterator_delete(kiter: *mut codes_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rewind the keys iterator."]
    #[doc = "  @param kiter         : valid codes_keys_iterator"]
    #[doc = "  @return              0 if OK, integer value on error"]
    pub fn codes_keys_iterator_rewind(kiter: *mut codes_keys_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_keys_iterator_set_flags(
        kiter: *mut codes_keys_iterator,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_keys_iterator_get_long(
        kiter: *const codes_keys_iterator,
        v: *mut ::std::os::raw::c_long,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_keys_iterator_get_double(
        kiter: *const codes_keys_iterator,
        v: *mut f64,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_keys_iterator_get_string(
        kiter: *const codes_keys_iterator,
        v: *mut ::std::os::raw::c_char,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_keys_iterator_get_bytes(
        kiter: *const codes_keys_iterator,
        v: *mut ::std::os::raw::c_uchar,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_update_sections_lengths(h: *mut codes_handle);
}
extern "C" {
    #[doc = " Convert an error code into a string"]
    #[doc = " @param code       : the error code"]
    #[doc = " @return           the error message"]
    pub fn codes_get_error_message(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn codes_get_type_name(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn codes_get_native_type(
        h: *const codes_handle,
        name: *const ::std::os::raw::c_char,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_check(
        call: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        e: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn codes_set_values(
        h: *mut codes_handle,
        codes_values: *mut codes_values,
        arg_count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_handle_new_from_partial_message_copy(
        c: *mut codes_context,
        data: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut codes_handle;
}
extern "C" {
    pub fn codes_handle_new_from_partial_message(
        c: *mut codes_context,
        data: *const ::std::os::raw::c_void,
        buflen: size_t,
    ) -> *mut codes_handle;
}
extern "C" {
    pub fn codes_is_missing(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_is_defined(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_bufr_key_is_header(
        h: *const codes_handle,
        key: *const ::std::os::raw::c_char,
        err: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_set_missing(
        h: *mut codes_handle,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_get_gaussian_latitudes(
        truncation: ::std::os::raw::c_long,
        latitudes: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_julian_to_datetime(
        jd: f64,
        year: *mut ::std::os::raw::c_long,
        month: *mut ::std::os::raw::c_long,
        day: *mut ::std::os::raw::c_long,
        hour: *mut ::std::os::raw::c_long,
        minute: *mut ::std::os::raw::c_long,
        second: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_datetime_to_julian(
        year: ::std::os::raw::c_long,
        month: ::std::os::raw::c_long,
        day: ::std::os::raw::c_long,
        hour: ::std::os::raw::c_long,
        minute: ::std::os::raw::c_long,
        second: ::std::os::raw::c_long,
        jd: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_julian_to_date(jdate: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn codes_date_to_julian(ddate: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn codes_get_reduced_row(
        pl: ::std::os::raw::c_long,
        lon_first: f64,
        lon_last: f64,
        npoints: *mut ::std::os::raw::c_long,
        ilon_first: *mut ::std::os::raw::c_long,
        ilon_last: *mut ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn codes_get_reduced_row_p(
        pl: ::std::os::raw::c_long,
        lon_first: f64,
        lon_last: f64,
        npoints: *mut ::std::os::raw::c_long,
        olon_first: *mut f64,
        olon_last: *mut f64,
    );
}
extern "C" {
    pub fn codes_get_message_offset(
        h: *const codes_handle,
        offset: *mut off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_get_message_size(
        h: *const codes_handle,
        size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_get_product_kind(
        h: *const codes_handle,
        product_kind: *mut ProductKind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_check_message_header(
        bytes: *const ::std::os::raw::c_void,
        length: size_t,
        product: ProductKind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_check_message_footer(
        bytes: *const ::std::os::raw::c_void,
        length: size_t,
        product: ProductKind,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_box_new(h: *mut codes_handle, error: *mut ::std::os::raw::c_int)
        -> *mut codes_box;
}
extern "C" {
    pub fn codes_box_get_points(
        box_: *mut codes_box,
        north: f64,
        west: f64,
        south: f64,
        east: f64,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_points;
}
extern "C" {
    pub fn codes_points_get_values(
        h: *mut codes_handle,
        points: *mut codes_points,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_grib_util_set_spec(
        h: *mut codes_handle,
        grid_spec: *const codes_util_grid_spec,
        packing_spec: *const codes_util_packing_spec,
        flags: ::std::os::raw::c_int,
        data_values: *const f64,
        data_values_count: size_t,
        err: *mut ::std::os::raw::c_int,
    ) -> *mut codes_handle;
}
extern "C" {
    pub fn codes_bufr_extract_headers_malloc(
        c: *mut codes_context,
        filename: *const ::std::os::raw::c_char,
        result: *mut *mut codes_bufr_header,
        num_messages: *mut ::std::os::raw::c_int,
        strict_mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_bufr_header_get_string(
        bh: *mut codes_bufr_header,
        key: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_char,
        len: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn codes_extract_offsets_malloc(
        c: *mut grib_context,
        filename: *const ::std::os::raw::c_char,
        product: ProductKind,
        offsets: *mut *mut off_t,
        num_messages: *mut ::std::os::raw::c_int,
        strict_mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
